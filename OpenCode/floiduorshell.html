<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>Алгоритм Флойда Уоршелла</title>

    <!-- Babylon.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
    <script src="https://cdn.babylonjs.com/recast.js"></script>
    <script src="https://cdn.babylonjs.com/ammo.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>
    <script src="https://cdn.babylonjs.com/Oimo.js"></script>
    <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

    <style>
      html,
      body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }

      #canvasZone {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
    <script>
      var canvas = document.getElementById("renderCanvas");

      var startRenderLoop = function (engine, canvas) {
        engine.runRenderLoop(function () {
          if (sceneToRender && sceneToRender.activeCamera) {
            sceneToRender.render();
          }
        });
      };

      var engine = null;
      var scene = null;
      var sceneToRender = null;
      var createDefaultEngine = function () {
        return new BABYLON.Engine(canvas, true, {
          preserveDrawingBuffer: true,
          stencil: true,
          disableWebGL2Support: false,
        });
      };
      var titels = [
        "Алгоритм Флойда-Уоршелла",
        "История и наименование",
        "Работа алгоритма",
        "Визуализация",
        "Необходимые переменные",
        "Реализация алгоритма",
        "Восстановление путей",
        "Сложность алгоритма",
        "Практические задачи",
        "Заключение",
      ];
      var texts = [
        "   Алгоритм Флойда-Уоршелла — алгоритм для нахождения кратчайших расстояний между всеми вершинами взвешенного графа или орграфа без циклов с отрицательными весами.\n   Если для вершин графа существует цикл, сумма весов которого меньше нуля, то кратчайшее расстояние между данными вершинами стремится к отрицательной бесконечности. В следствие этого, алгоритм не сможет за конечное количество итераций определить кратчайшее расстояние между данными вершинами. В таких случаях, алгоритм Флойда-Уоршелла используют для нахождения хотя бы одного цикла с отрицательными весами.",
        "   Алгоритм Флойда-Уоршелла является примером динамического программирования и был опубликован в своей ныне признанной форме Робертом Флойдом в 1962 году. Однако он по сути такой же, как алгоритмы, ранее опубликованные Бернардом Роем в 1959 году, а также Стивеном Уоршеллом в 1962 году для поиска транзитивного замыкания графа, и тесно связан с алгоритмом Клини (опубликовано в 1956 г.) для преобразования детерминированного конечного автомата в регулярное выражение. Современная формулировка алгоритма в виде трёх вложенных циклов «for» была впервые описана Питером Ингерманом также в 1962 году.",
        "   Ключевая идея алгоритма — разбиение процесса поиска кратчайших путей на фазы (как и в алгоритме Форда-Беллмана). В каждой фазе рассматривается путь из одной вершины в другую через третью (исходная, конечная и промежуточная вершины могут совпадать). Все возможные вариации такого перебора происходят посредством трех вложенных друг в друга циклов. В стандартной реализации алгоритм не предполагает записи самих путей, а только суммарное значение весов их ребер, однако с некоторой модификацией это возможно.",
        "   На визуализации представлен пример взвешенного ориентированного графа. Красным подсвечиваются исходная и конечная вершины, фиолетовым - вершина, через которую алгоритм пытается проложить путь. При нахождении нового кратчайшего пути, он будет выделен зеленым цветом. Слева снизу представлено окно информации, в котором отслеживается изменения матрицы кратчайших расстояний, а также отслеживаются три переменных - номера промежуточной, исходной и конечной вершин, которые являются счетчиками циклов. Такое расположение на подсказке иллюстрирует уровни вложенности (внешний цикл - промежуточная вершина, первично вложенный - исходная, вторично вложенный - конечная). При нахождении нового кратчайшего пути, его маршрут будет отображен снизу.",
        "   Для программной реализации алгоритма заведем необходимые переменные (листинг ниже). Константа inf хранит число, в рамках данной реализации условно стремящееся к бесконечности, двумерный массив distInit предназначен для хранения изначальной матрицы кратчайших расстояний, посредством циклов заполняется данными константами. Двумерный массив from1 нужен для реализации функции вывода кратчайшего пути, посредством циклов заполняется -1.\n   Далее перезаписываются значения массивов на номерах смежных и собственных вершин. В массиве distInit они перезаписываются на значения матрицы смежности, а в массиве from1 на номера вершин из которых начинается путь.",
        "   Функция реализации алгоритма Флойда-Уоршелла представлена ниже. В начале функции создается двумерный массив dist, изначально равный distInit. Посредством трех циклов, вложенных друг в друга, начинается тройной перебор всех вершин графа. Внешний цикл (счетчик – переменная v) обозначает вершину, через которую путь может пролегать, первично вложенный цикл (счетчик – переменная i) обозначает вершину из которой начинается путь, вторично вложенный цикл (счетчик – переменная j) обозначает вершину, в которую путь идет.\n   Если расстояние между вершинами i и j больше, чем сумма расстояний i-v и v-j, при условии, что суммирующиеся расстояния не равны условной бесконечности, значение массива dist между вершинами i и j перезаписывается на вышеуказанную сумму. Также в матрице from1 вершина, из которой проходил путь i-j перезаписывается на промежуточный пункт маршрута, то есть на вершину, из которой проходил путь v-j.\n   За счет того, что алгоритм состоит из трех вложенных друг в друга циклов, достигается та же сложность выполнения, что и у запуска поиска в ширину или алгоритма Дейкстры от каждой вершины графа (для получения матрицы кратчайших расстояний от каждой вершины до каждой), однако, за счет своего условия перезаписи кратчайшего расстояния, он позволяет избежать ограничения на веса ребер. Алгоритм Форда-Беллмана так же работает с произвольными весами, но имеет бóльшую сложность, за счет того, что использует такую же конструкцию из трех вложенных друг в друга циклов, но в результате выдает лишь массив расстояний для одной из вершин.",
        "   Реализация функции, возвращающей кратчайший маршрут из одной вершины до другой после исполнения алгоритма Флойда-Уоршелла, представлена ниже. На вход функция получает номера исходной и конечной вершин маршрута. В начале функции создается массив path, предназначенный для хранения маршрута, и переменная l, изначально равная нулю, работающая как внешний счетчик итераций цикла.\n   Запускается цикл со счетчиком v, который изначально принимает номер конечной вершины, и меняется на номера вершин, из которых маршрут прошел от исходной вершины до вершины v (предыдущего значения этой переменной), пока не станет равен -1. Посредством данного цикла выстраевается маршрут, который записывается в массив path в обратном порядке (от конечной вершины до исходной). Параллельно с каждой итерацией основного цикла, к счетчику l прибавляется единица, и, в случае, когда счетчик v не приходит к -1, а счетчик l стал больше количества вершин в графе, цикл прерывается (это происходит, так как при отсутствии циклов с отрицательными весами количество проходимых вершин в пути не может превышать количество путей в графе).\n   После этого удаляются дублирующиеся номера вершин, маршрут отражается для правильного отображения и выводится пользователю.",
        "   В связи с тем, что алгоритм состоит лишь из трех вложенных друг в друга циклов, производящих столько итераций, сколько вершин в графе, очевидно, что его сложность оценивается как O(V³).",
        "   В общем и целом, алгоритм Флойда-Уоршелла применяется в тех же сферах, что и алгоритм Дейкстры, а именно в транспортных сетях, интернет маршрутизации, робототехнике и логистике.",
        "   По итогу работы алгоритма мы получим матрицу кратчайших расстояний всех пар вершин. Предлагаем вам самостоятельно досмотреть визуализацию алгоритма и перейти к тестированию.",
      ];
      var index = 0;
      var isVisibleAfter = true;

      var matrixSm = [
        [0, 5, 0, 0],
        [0, 0, 5, 3],
        [-3, 0, 0, 0],
        [2, 0, -5, 0],
      ];

      /*var matrixSm = [
    [0, 15, 0, 0, 30],
    [15, 0, 0, 85, 0],
    [0, 0, 0, 0, 68],
    [0, 85, 0, 0, 45],
    [30, 0, 68, 45, 0]
]*/

      var quantity = matrixSm.length;

      const inf = 1e9;
      var distText = [];
      var distInit = [];
      var from1 = [];

      for (let i = 0; i < quantity; i++) {
        distInit[i] = [];
        distText[i] = [];
        from1[i] = [];
      }
      for (let i = 0; i < quantity; i++) {
        for (let j = 0; j < quantity; j++) {
          distInit[i][j] = inf;
          distText[i][j] = 0;
          from1[i][j] = -1;
        }
      }
      for (let i = 0; i < quantity; i++) {
        for (let j = 0; j < quantity; j++) {
          if (i == j || matrixSm[i][j] != 0) {
            distInit[i][j] = matrixSm[i][j];
            from1[i][j] = i;
          }
        }
      }

      var spheres = [];
      var spheresXs = [];
      var spheresYs = [];
      var spheresZs = [];

      var centerX = []; //местоположение сфер с весом ребра
      var centerY = []; //местоположение сфер с весом ребра
      var centerZ = []; //местоположение сфер с весом ребра
      var centerSpheres = []; //массив хранения сфер весов
      var weights = [];
      var weightsRects = []; //матрица хранения выводимых прямоугольников
      var weightsRectsLabels = [];

      for (let i = 0; i < quantity; i++) {
        weights[i] = [];
        weightsRects[i] = [];
        weightsRectsLabels[i] = [];
      }

      for (let i = 0; i < quantity; i++) {
        for (let j = 0; j < quantity; j++) {
          weights[i][j] = 0;
          weightsRects[i][j] = 0;
          weightsRectsLabels[i][j] = 0;
        }
      }

      for (let i = 0; i < quantity; i++) {
        for (let j = 0; j < quantity; j++) {
          weights[i][j] = matrixSm[j][i];
        }
      }

      var points1 = []; //массив хранения крайних координат стрелочки
      const widths = [20, 20, 20, 20];
      var line1 = []; //массив хранения линий стрелочек
      var cap1 = []; //массив хранения указателей стрелочек

      var targets = [];
      var dragBehaviors = [];
      var rectsPopUp = [];
      var linesPopUp = [];
      var labelsPopUp = [];
      let isPopUpsShown = true;

      var r = 0.13;
      var g = 0.13;
      var b = 0.13;

      var skinColor = "#e5ded6"; //"#EAEAE3""#272727""black"
      var dark = "#222222"; //"#fde401""white""#6303F7"
      var orange = "#FE6C21"; //"#ff652f"
      var green = "#3DD085"; //"#07ef93"
      var purple = "#BF4DEB";

      var images = [
        "https://raw.githubusercontent.com/pave228/Babylon/main/floiduorshellval.jpg",
        "https://raw.githubusercontent.com/pave228/Babylon/main/floiduorshell.jpg",
        "https://raw.githubusercontent.com/pave228/Babylon/main/floiduorshellpath.jpg",
        "https://raw.githubusercontent.com/pave228/Babylon/main/floiduorshelldiag.png"
      ];

      var setImage = function (imageIndex, rect, width, height) {
        var image = new BABYLON.GUI.Image("img", images[imageIndex]);
        image.width = width;
        image.height = height;
        image.outlineWidth = "4px";

        rect.addControl(image);
      };

      var preScene = function (scene) {
        //Функция создания необходимых элементов сцены
        var camera = new BABYLON.ArcRotateCamera(
          "camera",
          Math.PI / 3,
          Math.PI / 3,
          10,
          BABYLON.Vector3.Zero(),
          scene
        );

        camera.setTarget(BABYLON.Vector3.Zero());

        camera.position = new BABYLON.Vector3(1000, 0, -1000);

        camera.attachControl(canvas, true);
        camera.panningSensibility = 15;

        const light = new BABYLON.HemisphericLight(
          "light",
          new BABYLON.Vector3(0, 1, 0),
          scene
        );
        light.intensity = 0.7;
      };

      var floidUorshell = function () {
        var dist = distInit;

        for (let v = 0; v < quantity; v++) {
          for (let i = 0; i < quantity; i++) {
            for (let j = 0; j < quantity; j++) {
              if (
                dist[i][v] != inf &&
                dist[v][j] != inf &&
                dist[i][j] > dist[i][v] + dist[v][j]
              ) {
                dist[i][j] = dist[i][v] + dist[v][j];
                from1[i][j] = from1[v][j];
              }
            }
          }
        }
        console.log(dist);
      };

      var showPath = function (start, finish) {
        let path = [];
        let l = 0;
        for (let v = finish; v != -1; v = from1[start][v]) {
          path.push(v);
          l++;
          if (l > quantity) {
            break;
          }
        }
        for (let n = 0; n < quantity; n++) {
          if (path[path.length - 1] == path[path.length - 2]) {
            path.pop();
          }
        }
        path.reverse();
        console.log(path);
      };

      var floidUorshellVisualisation = function () {
        var advancedTexture =
          BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

        var buttonNextLink = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonNextLink",
          "Тестирование ⇨"
        );
        buttonNextLink.width = "200px";
        buttonNextLink.height = "40px";
        buttonNextLink.fontSize = "2.5%";
        buttonNextLink.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonNextLink.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        buttonNextLink.top = "50px";
        buttonNextLink.left = "-20px";
        buttonNextLink.color = dark;
        //buttonNextLink.cornerRadius = 20;
        buttonNextLink.background = skinColor;
        //buttonNextLink.isVisible = false;
        buttonNextLink.thickness = 1;

        buttonNextLink.onPointerClickObservable.add(function () {
          window.open("questions3.html");
          window.close("floiduorshell.html");
        });

        advancedTexture.addControl(buttonNextLink);

        var diagramm = new BABYLON.GUI.Image(
          "img",
          "https://raw.githubusercontent.com/pave228/Babylon/main/floiduorshelldiag.png"
        );

        diagramm.width = "600px";
        diagramm.height = "500px";
        diagramm.left = 10;
        diagramm.top = -70;
        //diagramm.top = "280px";
        //diagramm.left = "-700px";
        diagramm.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        diagramm.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        diagramm.outlineWidth = "0px";

        advancedTexture.addControl(diagramm);

        var gradientRed = new BABYLON.GUI.LinearGradient(0, 0, 400, 400);
        gradientRed.addColorStop(0, orange);
        gradientRed.addColorStop(1, orange);

        var gradientGreen = new BABYLON.GUI.LinearGradient(0, 0, 400, 400);
        gradientGreen.addColorStop(0, green);
        gradientGreen.addColorStop(1, green);

        var gradientDefault = new BABYLON.GUI.LinearGradient(0, 0, 400, 400);
        gradientDefault.addColorStop(0, skinColor);
        gradientDefault.addColorStop(1, skinColor);

        var gradientPurple = new BABYLON.GUI.LinearGradient(0, 0, 400, 400);
        gradientPurple.addColorStop(0, purple);
        gradientPurple.addColorStop(1, purple);

        var rectInfo = new BABYLON.GUI.Rectangle();
        rectInfo.width = "400px";
        rectInfo.height = "130px";
        //rectInfo.cornerRadius = 10;
        rectInfo.color = dark;
        rectInfo.thickness = 1;
        rectInfo.background = skinColor;
        rectInfo.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        rectInfo.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        rectInfo.paddingLeftInPixels = 200;

        var rectMatrix = new BABYLON.GUI.Rectangle();
        rectMatrix.width = "200px";
        rectMatrix.height = "200px";
        //rectMatrix.cornerRadius = 10;
        rectMatrix.color = dark;
        rectMatrix.thickness = 1;
        rectMatrix.background = skinColor;
        rectMatrix.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        rectMatrix.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;

        var textblockInfo = new BABYLON.GUI.TextBlock();
        textblockInfo.color = dark;
        textblockInfo.textWrapping = true;

        textblockInfo.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        textblockInfo.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        textblockInfo.textHorizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        textblockInfo.textVerticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        textblockInfo.textWrapping = BABYLON.GUI.TextWrapping.WordWrap;
        textblockInfo.resizeToFit = true;
        textblockInfo.paddingLeft = "10px";
        textblockInfo.paddingRight = "20px";
        textblockInfo.paddingBottom = "15px";
        textblockInfo.fontSize = "20";

        rectInfo.addControl(textblockInfo);

        updateInfo(rectInfo, textblockInfo, textblockInfo.text, diagramm);

        var textblockMatrix = new BABYLON.GUI.TextBlock();
        textblockMatrix.color = dark;
        textblockMatrix.textWrapping = true;
        textblockMatrix.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        textblockMatrix.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        textblockMatrix.textHorizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        textblockMatrix.textVerticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        textblockMatrix.textWrapping = BABYLON.GUI.TextWrapping.WordWrap;
        textblockMatrix.resizeToFit = true;
        textblockMatrix.fontSize = "20";

        updateInfo(rectInfo, textblockInfo, textblockInfo.text, diagramm);
        updateInfo(rectMatrix, textblockMatrix, textblockMatrix.text, diagramm);

        var lineRed = new BABYLON.GUI.Line();
        lineRed.lineWidth = 3;
        lineRed.color = orange;

        var lineGreen = new BABYLON.GUI.Line();
        lineGreen.lineWidth = 3;
        lineGreen.color = green;

        var buttonNextStepRed = BABYLON.GUI.Button.CreateSimpleButton(
          "butNextStep",
          "⇨"
        );
        buttonNextStepRed.width = "40px";
        buttonNextStepRed.height = "40px";
        buttonNextStepRed.fontSize = "6%";
        buttonNextStepRed.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonNextStepRed.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        buttonNextStepRed.top = "-20px";
        buttonNextStepRed.left = "-20px";
        buttonNextStepRed.color = dark;
        //buttonNextStepRed.cornerRadius = 20;
        buttonNextStepRed.background = "#f7f0eb";
        buttonNextStepRed.thickness = 0;

        advancedTexture.addControl(buttonNextStepRed);

        var dist = distInit;

        for (let i = 0; i < quantity; i++) {
          for (let j = 0; j < quantity; j++) {
            distText[i][j] = distInit[i][j];
            if (distText[i][j] == inf) {
              distText[i][j] = "∞";
            }
          }
          rectMatrix.addControl(textblockMatrix);
          textblockMatrix.text = textblockMatrix.text + distText[i] + "\n";
        }
        updateInfo(rectInfo, textblockInfo, textblockInfo.text, diagramm);
        updateInfo(rectMatrix, textblockMatrix, textblockMatrix.text, diagramm);

        var linesWays = [];

        var v = -1;
        var i = -1;
        var j = -1;

        buttonNextStepRed.onPointerClickObservable.add(function () {
          var buttonNextStepBlue = BABYLON.GUI.Button.CreateSimpleButton(
            "butNextStep",
            "⇨"
          );
          buttonNextStepBlue.width = "40px";
          buttonNextStepBlue.height = "40px";
          buttonNextStepBlue.fontSize = "6%";
          buttonNextStepBlue.horizontalAlignment =
            BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
          buttonNextStepBlue.verticalAlignment =
            BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
          buttonNextStepBlue.top = "-20px";
          buttonNextStepBlue.left = "-20px";
          buttonNextStepBlue.color = dark;
          //buttonNextStepBlue.cornerRadius = 20;
          buttonNextStepBlue.background = "#f7f0eb";
          buttonNextStepBlue.thickness = 0;

          advancedTexture.addControl(buttonNextStepBlue);

          if (v >= quantity - 1) {
            buttonNextStepGreen.isVisible = false;
            buttonNextStepBlue.isVisible = false;
            buttonNextStepRed.isVisible = false;
          }

          i = -1;
          lineRed.isVisible = false;

          while (linesWays[0] != undefined) {
            linesWays[linesWays.length - 1].isVisible = false;
            linesWays.pop();
          }
          lineGreen.isVisible = false;
          v++;

          for (let k = 0; k < quantity; k++) {
            rectsPopUp[k].backgroundGradient = gradientDefault;
          }
          rectsPopUp[v].backgroundGradient = gradientPurple;

          textblockInfo.text =
            "\nЧерез вершину " +
            (v + 1) +
            "\nИз вершины " +
            (i + 1) +
            "\nВ вершину " +
            (j + 1);

          updateInfo(rectInfo, textblockInfo, textblockInfo.text, diagramm);
          updateInfo(
            rectMatrix,
            textblockMatrix,
            textblockMatrix.text,
            diagramm
          );

          buttonNextStepBlue.onPointerClickObservable.add(function () {
            for (let k = 0; k < quantity; k++) {
              rectsPopUp[k].backgroundGradient = gradientDefault;
            }
            rectsPopUp[v].backgroundGradient = gradientPurple;

            if (i == quantity - 1 && j == quantity - 1 && v == quantity - 1) {
              rectsPopUp[v].backgroundGradient = gradientDefault;

              buttonNextStepRed.isVisible = false;
            }
            if (i >= quantity - 1) {
              buttonNextStepBlue.isVisible = false;
              buttonNextStepGreen.isVisible = false;
              buttonNextStepRed.isVisible = true;
            }

            var buttonNextStepGreen = BABYLON.GUI.Button.CreateSimpleButton(
              "butNextStep",
              "⇨"
            );
            buttonNextStepGreen.width = "40px";
            buttonNextStepGreen.height = "40px";
            buttonNextStepGreen.fontSize = "6%";
            buttonNextStepGreen.horizontalAlignment =
              BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            buttonNextStepGreen.verticalAlignment =
              BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            buttonNextStepGreen.top = "-20px";
            buttonNextStepGreen.left = "-20px";
            buttonNextStepGreen.color = dark;
            //buttonNextStepGreen.cornerRadius = 20;
            buttonNextStepGreen.background = "#f7f0eb";
            buttonNextStepGreen.thickness = 0;

            advancedTexture.addControl(buttonNextStepGreen);

            j = -1;
            lineRed.isVisible = false;

            while (linesWays[0] != undefined) {
              linesWays[linesWays.length - 1].isVisible = false;
              linesWays.pop();
            }

            lineGreen.isVisible = false;
            i++;

            textblockInfo.text =
              "\nЧерез вершину " +
              (v + 1) +
              "\nИз вершины " +
              (i + 1) +
              "\nВ вершину " +
              (j + 1);

            updateInfo(rectInfo, textblockInfo, textblockInfo.text, diagramm);
            updateInfo(
              rectMatrix,
              textblockMatrix,
              textblockMatrix.text,
              diagramm
            );
            buttonNextStepGreen.onPointerClickObservable.add(function () {
              if (j >= quantity - 2) {
                buttonNextStepGreen.isVisible = false;
                buttonNextStepBlue.isVisible = true;
              }
              lineRed.isVisible = false;
              while (linesWays[0] != undefined) {
                linesWays[linesWays.length - 1].isVisible = false;
                linesWays.pop();
              }
              lineGreen.isVisible = false;
              j++;
              for (let k = 0; k < quantity; k++) {
                rectsPopUp[k].backgroundGradient = gradientDefault;
              }

              rectsPopUp[v].backgroundGradient = gradientPurple;

              lineRed.isVisible = true;
              advancedTexture.addControl(lineRed);
              lineRed.linkWithMesh(spheres[i]);
              lineRed.connectedControl = rectsPopUp[j];

              rectsPopUp[i].backgroundGradient = gradientRed;
              rectsPopUp[j].backgroundGradient = gradientRed;

              textblockInfo.text =
                "\nЧерез вершину " +
                (v + 1) +
                "\nИз вершины " +
                (i + 1) +
                "\nВ вершину " +
                (j + 1);

              updateInfo(rectInfo, textblockInfo, textblockInfo.text, diagramm);
              updateInfo(
                rectMatrix,
                textblockMatrix,
                textblockMatrix.text,
                diagramm
              );
              if (
                dist[i][v] != 1e9 &&
                dist[v][j] != 1e9 &&
                dist[i][j] > dist[i][v] + dist[v][j]
              ) {
                for (let k = 0; k < quantity; k++) {
                  rectsPopUp[k].backgroundGradient = gradientDefault;
                }

                dist[i][j] = dist[i][v] + dist[v][j];
                from1[i][j] = from1[v][j];

                let path = [];
                let l = 0;
                for (let v = j; v != -1; v = from1[i][v]) {
                  path.push(v);
                  l++;
                  if (l > quantity) {
                    break;
                  }
                }
                for (let n = 0; n < quantity; n++) {
                  if (path[path.length - 1] == path[path.length - 2]) {
                    path.pop();
                  }
                }
                path.reverse();
                let pathText = [];
                for (let n = 0; n < path.length; n++) {
                  pathText[n] = path[n] + 1;
                }
                textblockInfo.text =
                  "\nЧерез вершину " +
                  (v + 1) +
                  "\nИз вершины " +
                  (i + 1) +
                  "\nВ вершину " +
                  (j + 1) +
                  "\nПуть " +
                  pathText;

                updateInfo(
                  rectInfo,
                  textblockInfo,
                  textblockInfo.text,
                  diagramm
                );
                updateInfo(
                  rectMatrix,
                  textblockMatrix,
                  textblockMatrix.text,
                  diagramm
                );
                for (let k = 0; k < path.length; k++) {
                  var line2 = new BABYLON.GUI.Line();
                  line2.lineWidth = 3;
                  line2.color = green;
                  linesWays.push(line2);
                  advancedTexture.addControl(linesWays[k]);
                  linesWays[k].isVisible = true;
                  if (k != path.length - 1) {
                    linesWays[k].linkWithMesh(spheres[path[k]]);
                    linesWays[k].connectedControl = rectsPopUp[path[k + 1]];
                  }
                  if (k == 0) {
                    rectsPopUp[path[k]].backgroundGradient = gradientRed;
                  } else if (k == path.length - 1) {
                    rectsPopUp[path[k]].backgroundGradient = gradientRed;
                  } else {
                    rectsPopUp[path[k]].backgroundGradient = gradientGreen;
                  }
                }
                textblockMatrix.text = "";
                updateInfo(
                  rectInfo,
                  textblockInfo,
                  textblockInfo.text,
                  diagramm
                );
                updateInfo(
                  rectMatrix,
                  textblockMatrix,
                  textblockMatrix.text,
                  diagramm
                );
                for (let i = 0; i < quantity; i++) {
                  for (let j = 0; j < quantity; j++) {
                    distText[i][j] = dist[i][j];
                    if (distText[i][j] == inf) {
                      distText[i][j] = "∞";
                    }
                  }
                  rectMatrix.addControl(textblockMatrix);
                  textblockMatrix.text =
                    textblockMatrix.text + distText[i] + "\n";
                }
                updateInfo(
                  rectInfo,
                  textblockInfo,
                  textblockInfo.text,
                  diagramm
                );
                updateInfo(
                  rectMatrix,
                  textblockMatrix,
                  textblockMatrix.text,
                  diagramm
                );
              }
            });
          });
          advancedTexture.addControl(rectInfo);

          advancedTexture.addControl(rectMatrix);
        });
        console.log(dist);
      };

      var currentAT = 0;
      function updateInfo(rect, textblock, text) {
        var advancedTexture =
          BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        currentAT = advancedTexture;
        currentAT.addControl(rect);

        textblock.text = text;
        rect.addControl(textblock);
      }

      var textWindowFullScreen = function (howManySlides) {
        var advancedTexture =
          BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

        var rectInput = new BABYLON.GUI.Rectangle();
        rectInput.width = "100%";
        rectInput.height = "100%";
        //rectInput.cornerRadius = 10;
        //rectInput.color = skinColor;
        rectInput.thickness = 0;
        //rectInput.background = skinColor;

        var placeholder1 = new BABYLON.GUI.Image(
          "img",
          "https://raw.githubusercontent.com/pave228/Babylon/main/placeholder_left_bottom.jpg"
        );
        placeholder1.width = "1352px";
        placeholder1.height = "806px";
        placeholder1.top = "280px";
        placeholder1.left = "-700px";
        placeholder1.outlineWidth = "0px";

        var placeholder2 = new BABYLON.GUI.Image(
          "img",
          "https://raw.githubusercontent.com/pave228/Babylon/main/placeholder_left_top.jpg"
        );
        placeholder2.width = "1227px";
        placeholder2.height = "629px";
        placeholder2.top = "-500px";
        placeholder2.left = "-650px";
        placeholder2.outlineWidth = "0px";

        var placeholder3 = new BABYLON.GUI.Image(
          "img",
          "https://raw.githubusercontent.com/pave228/Babylon/main/placeholder_right_top.jpg"
        );
        placeholder3.width = "1338px";
        placeholder3.height = "960px";
        placeholder3.top = "-400px";
        placeholder3.left = "650px";
        placeholder3.outlineWidth = "0px";

        placeholder1.alpha = 0.1;
        placeholder2.alpha = 0.15;
        placeholder3.alpha = 0.1;
        rectInput.addControl(placeholder1);
        rectInput.addControl(placeholder2);
        rectInput.addControl(placeholder3);

        var gradientDefault = new BABYLON.GUI.LinearGradient(0, 0, 400, 400);
        gradientDefault.addColorStop(0, skinColor);
        gradientDefault.addColorStop(1, skinColor);
        rectInput.backgroundGradient = gradientDefault;

        var title = new BABYLON.GUI.TextBlock();
        title.width = "90%";
        title.fontSize = "5%";
        title.color = dark;
        title.fontStyle = "Bold";
        title.top = "-45%";
        title.textWrapping = true;
        title.text = titels[index];
        rectInput.addControl(title);

        var textblock = new BABYLON.GUI.TextBlock();
        //textblock.width = "99%"
        //textblock.fontSize = "5%";
        textblock.color = dark;
        //textblock.top = "-45%";
        textblock.textWrapping = true;
        textblock.text = texts[index];
        textblock.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        textblock.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        textblock.textHorizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        textblock.textVerticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        textblock.textWrapping = BABYLON.GUI.TextWrapping.WordWrap;
        textblock.resizeToFit = true;
        textblock.paddingTop = "10px";
        textblock.paddingLeft = "30px";
        textblock.paddingRight = "20px";
        textblock.paddingBottom = "15px";
        textblock.fontSize = "25";

        var buttonNext = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonNext",
          "⇨"
        );
        buttonNext.width = "40px";
        buttonNext.height = "40px";
        buttonNext.fontSize = "6%";
        buttonNext.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonNext.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        buttonNext.top = "-20px";
        buttonNext.left = "-20px";
        buttonNext.color = dark;
        //buttonNext.cornerRadius = 20;
        buttonNext.background = skinColor;
        buttonNext.thickness = 0;

        if (index == howManySlides - 1) {
          buttonNext.onPointerClickObservable.add(function () {
            rectInput.isVisible = false;
            index++;
            console.log(index);
            textWindowFramed();
          });
        } else {
          buttonNext.onPointerClickObservable.add(function () {
            rectInput.isVisible = false;
            index++;
            console.log(index);
          });
        }

        var buttonBack = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonBack",
          "⇦"
        );
        buttonBack.width = "40px";
        buttonBack.height = "40px";
        buttonBack.fontSize = "6%";
        buttonBack.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        buttonBack.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        buttonBack.top = "-20px";
        buttonBack.left = "20px";
        buttonBack.color = dark;
        //buttonBack.cornerRadius = 30;
        buttonBack.background = skinColor;
        buttonBack.thickness = 0;

        if (index > 0) {
          buttonBack.onPointerClickObservable.add(function () {
            rectInput.isVisible = false;
            index--;
            console.log(index);
            textWindowFullScreen();
          });
        } else {
          buttonBack.isVisible = false;
        }

        var buttonHome = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonHome",
          "⌂"
        );
        buttonHome.width = "40px";
        buttonHome.height = "40px";
        buttonHome.fontSize = "6%";
        buttonHome.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        buttonHome.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        buttonHome.top = "-20px";
        buttonHome.left = "20px";
        buttonHome.color = dark;
        //buttonHome.cornerRadius = 30;
        buttonHome.background = skinColor;
        buttonHome.thickness = 0;

        buttonHome.onPointerClickObservable.add(function () {
          window.open("homePage.html");
          window.close("floiduorshell.html");
        });

        var sv = new BABYLON.GUI.ScrollViewer();
        sv.thickness = 1;
        sv.color = dark;
        sv.width = "90%";
        sv.height = "75%";
        sv.top = "10px";
        sv.background = skinColor;
        sv.clipChildren = false;
        rectInput.addControl(sv);
        rectInput.addControl(sv);

        var stackV = new BABYLON.GUI.StackPanel();
        stackV.isVertical = true;

        stackV.addControl(textblock);
        sv.addControl(stackV);
 
        advancedTexture.addControl(rectInput);

        setImage(3, stackV, "693px", "575px")

        rectInput.addControl(buttonNext);
        rectInput.addControl(buttonBack);
        rectInput.addControl(buttonHome);
      };

      var textWindowFramed = function () {
        var advancedTexture =
          BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

        var rectInput = new BABYLON.GUI.Rectangle();
        rectInput.width = "40%";
        rectInput.height = "100%";
        //rectInput.cornerRadius = 10;
        rectInput.color = dark;
        rectInput.thickness = 1;
        rectInput.background = skinColor;
        rectInput.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        rectInput;

        hideShowRectButtons(rectInput, advancedTexture, "right", "top");

        advancedTexture.addControl(rectInput);

        var gradientDefault = new BABYLON.GUI.LinearGradient(0, 0, 400, 400);
        gradientDefault.addColorStop(0, skinColor);
        gradientDefault.addColorStop(1, skinColor);
        rectInput.backgroundGradient = gradientDefault;

        var title = new BABYLON.GUI.TextBlock();
        title.width = "70%";
        title.fontSize = "5%";
        title.color = dark;
        title.top = "-45%";
        title.textWrapping = true;
        title.text = titels[index];
        rectInput.addControl(title);

        var textblock = new BABYLON.GUI.TextBlock();
        //textblock.width = "99%"
        //textblock.fontSize = "5%";
        textblock.color = dark;
        //textblock.top = "-45%";
        textblock.textWrapping = true;
        textblock.text = texts[index];
        textblock.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        textblock.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        textblock.textHorizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        textblock.textVerticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        textblock.textWrapping = BABYLON.GUI.TextWrapping.WordWrap;
        textblock.resizeToFit = true;
        textblock.paddingTop = "10px";
        textblock.paddingLeft = "30px";
        textblock.paddingRight = "20px";
        textblock.paddingBottom = "15px";
        textblock.fontSize = "25";

        var buttonNext = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonNext",
          "⇨"
        );
        buttonNext.width = "40px";
        buttonNext.height = "40px";
        buttonNext.fontSize = "6%";
        buttonNext.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonNext.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        buttonNext.top = "-20px";
        buttonNext.left = "-20px";
        buttonNext.color = dark;
        //buttonNext.cornerRadius = 20;
        buttonNext.background = skinColor;
        buttonNext.thickness = 0;

        var buttonNextLink = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonNextLink",
          "⇨"
        );
        buttonNextLink.width = "40px";
        buttonNextLink.height = "40px";
        buttonNextLink.fontSize = "6%";
        buttonNextLink.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonNextLink.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        buttonNextLink.top = "-20px";
        buttonNextLink.left = "-20px";
        buttonNextLink.color = dark;
        //buttonNextLink.cornerRadius = 20;
        buttonNextLink.background = skinColor;
        buttonNextLink.isVisible = false;
        buttonNextLink.thickness = 0;

        var buttonBack = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonBack",
          "⇦"
        );
        buttonBack.width = "40px";
        buttonBack.height = "40px";
        buttonBack.fontSize = "6%";
        buttonBack.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        buttonBack.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        buttonBack.top = "-20px";
        buttonBack.left = "20px";
        buttonBack.color = dark;
        //buttonBack.cornerRadius = 30;
        buttonBack.background = skinColor;
        buttonBack.thickness = 0;

        var buttonHome = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonHome",
          "⌂"
        );
        buttonHome.width = "40px";
        buttonHome.height = "40px";
        buttonHome.fontSize = "6%";
        buttonHome.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        buttonHome.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        buttonHome.top = "-20px";
        //buttonHome.left = "20px";
        buttonHome.color = dark;
        //buttonHome.cornerRadius = 30;
        buttonHome.background = skinColor;
        buttonHome.thickness = 0;

        buttonHome.onPointerClickObservable.add(function () {
          window.open("homePage.html");
          window.close("floiduorshell.html");
        });

        var sv = new BABYLON.GUI.ScrollViewer();
        sv.thickness = 1;
        sv.color = dark;
        sv.width = "90%";
        sv.height = "75%";
        sv.top = "10px";
        sv.background = skinColor;
        sv.clipChildren = false;
        rectInput.addControl(sv);
        rectInput.addControl(sv);

        var stackV = new BABYLON.GUI.StackPanel();
        stackV.isVertical = true;

        stackV.addControl(textblock);
        sv.addControl(stackV);

        rectInput.addControl(buttonNext);
        //rectInput.addControl(buttonBack);
        rectInput.addControl(buttonHome);

        buttonNext.onPointerClickObservable.add(function () {
          rectInput.isVisible = false;
          index++;
          console.log(index);
          textWindowFramed();
        });
        buttonBack.onPointerClickObservable.add(function () {
          rectInput.isVisible = false;
          index--;
          console.log(index);
          textWindowFramed();
        });

        if (index == 4) {
          setImage(0, stackV, "332px", "408px");
        } else if (index == 5) {
          setImage(1, stackV, "430px", "312px");
        } else if (index == 6) {
          setImage(2, stackV, "314px", "334px");
        }

        if (index == texts.length - 1) {
          buttonNextLink.onPointerClickObservable.add(function () {
            rectInput.isVisible = false;
            buttonNext.isVisible = false;
          });
          buttonNextLink.isVisible = true;
          rectInput.addControl(buttonNextLink);
        }
      };

      var hideShowRectButtons = function (
        rect,
        advancedTexture,
        corner_RL,
        corner_TB
      ) {
        var buttonFullScreen = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonFullScreen",
          "❐"
        );
        buttonFullScreen.width = "30px";
        buttonFullScreen.height = "30px";
        buttonFullScreen.fontSize = "20";
        buttonFullScreen.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonFullScreen.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        buttonFullScreen.top = "5px";
        buttonFullScreen.left = "-5px";
        buttonFullScreen.color = dark;
        buttonFullScreen.thickness = 2;
        //buttonFullScreen.cornerRadius = 20;
        buttonFullScreen.background = skinColor;

        var buttonWindowed = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonWindowed",
          "❐"
        );
        buttonWindowed.width = "30px";
        buttonWindowed.height = "30px";
        buttonWindowed.fontSize = "20";
        buttonWindowed.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonWindowed.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        buttonWindowed.top = "5px";
        buttonWindowed.left = "-5px";
        buttonWindowed.color = dark;
        buttonWindowed.thickness = 2;
        //buttonWindowed.cornerRadius = 20;
        buttonWindowed.isVisible = false;
        buttonWindowed.background = skinColor;

        var buttonHideWindow = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonHideWindow",
          "—"
        );
        buttonHideWindow.width = "30px";
        buttonHideWindow.height = "30px";
        buttonHideWindow.fontSize = "20";
        buttonHideWindow.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonHideWindow.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        buttonHideWindow.top = "5px";
        buttonHideWindow.left = "-40px";
        buttonHideWindow.color = dark;
        buttonHideWindow.thickness = 2;
        //buttonHideWindow.cornerRadius = 20;
        //buttonHideWindow.isVisible = false;
        buttonHideWindow.background = skinColor;

        var buttonShowWindow = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonShowWindow",
          "❐"
        );
        buttonShowWindow.width = "30px";
        buttonShowWindow.height = "30px";
        buttonShowWindow.fontSize = "20";
        buttonShowWindow.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonShowWindow.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        buttonShowWindow.top = "5px";
        buttonShowWindow.left = "-5px";
        buttonShowWindow.color = dark;
        buttonShowWindow.thickness = 2;
        //buttonShowWindow.cornerRadius = 20;
        //buttonShowWindow.isVisible = false;
        buttonShowWindow.background = skinColor;

        var rectWidth = rect.width;
        var rectHeight = rect.height;

        var rectHiden = new BABYLON.GUI.Rectangle();
        rectHiden.isVisible = false;
        rectHiden.width = "42px";
        rectHiden.height = "42px";
        rectHiden.color = dark;
        rectHiden.thickness = 0;
        rectHiden.background = "#f7f0eb";
        rectHiden.alpha = 0.15;
        if (corner_TB == "top") {
          rectHiden.verticalAlignment =
            BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        } else if (corner_TB == "bottom") {
          rectHiden.verticalAlignment =
            BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        }

        if (corner_RL == "right") {
          rectHiden.horizontalAlignment =
            BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        } else if (corner_RL == "left") {
          rectHiden.horizontalAlignment =
            BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        }

        buttonWindowed.onPointerClickObservable.add(function () {
          rect.width = rectWidth;
          rect.height = rectHeight;
          buttonWindowed.isVisible = false;
          buttonFullScreen.isVisible = true;
        });

        buttonFullScreen.onPointerClickObservable.add(function () {
          rect.width = "100%";
          rect.height = "100%";
          buttonFullScreen.isVisible = false;
          buttonWindowed.isVisible = true;
        });

        buttonHideWindow.onPointerClickObservable.add(function () {
          rect.isVisible = false;
          rectHiden.isVisible = true;

          //buttonFullScreen.isVisible = false;
          //buttonWindowed.isVisible = true;
        });

        buttonShowWindow.onPointerClickObservable.add(function () {
          rect.isVisible = true;
          rectHiden.isVisible = false;

          //buttonFullScreen.isVisible = false;
          //buttonWindowed.isVisible = true;
        });

        rectHiden.addControl(buttonShowWindow);
        advancedTexture.addControl(rectHiden);
        rect.addControl(buttonFullScreen);
        rect.addControl(buttonWindowed);
        rect.addControl(buttonHideWindow);
      };

      var xs = [];
      var ys = [];
      var getCoord = function () {
        var q = quantity;
        //var q = 10;
        var r = q;
        var j = 0;
        for (i = 0; i < Math.PI * 2; i += (Math.PI * 2) / q) {
          x = r * Math.sin(i);
          y = r * Math.cos(i);
          xs[j] = x * 20;
          ys[j] = y * 20;
          j++;
        }
      };

      var graphOrWe = function (scene) {
        getCoord();

        var advancedTexture =
          BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

        console.log("weights", weights);
        let sphereNum = 0;
        let sphereNode = new BABYLON.Mesh("spheres", scene);

        for (let i = 0; i < quantity; i++) {
          spheres[i] = 0;
          spheresXs[i] = 0;
          spheresYs[i] = 0;
          spheresZs[i] = 0;
          targets[i] = 0;
          dragBehaviors[i] = 0;
          rectsPopUp[i] = 0;
          linesPopUp[i] = 0;
          labelsPopUp[i] = 0;

          centerSpheres[i] = [];
          centerX[i] = [];
          centerY[i] = [];
          centerZ[i] = [];

          line1[i] = [];
          points1[i] = [];
          cap1[i] = [];
        }
        for (let i = 0; i < quantity; i++) {
          for (let j = 0; j < quantity; j++) {
            centerSpheres[i][j] = 0;
            centerX[i][j] = 0;
            centerY[i][j] = 0;
            centerZ[i][j] = 0;

            line1[i][j] = 0;
            points1[i][j] = 0;
            cap1[i][j] = 0;
          }
        }

        for (let i = 0; i < quantity; i++) {
          let name = `sphera${sphereNum++}`;
          let sphere = BABYLON.MeshBuilder.CreateSphere(
            name,
            { diameter: 32, segments: 32 },
            scene
          );
          let variance1 = xs[i];
          let variance2 = ys[i];
          let variance3 = 0; //Math.floor(Math.random()*50)

          sphere.position = new BABYLON.Vector3(
            variance1,
            variance2,
            variance3
          );

          spheresXs[i] = variance1;
          spheresYs[i] = variance2;
          spheresZs[i] = variance3;
          sphere.outlineWidth = 0.1;
          sphereNode.addChild(sphere);

          spheres[i] = sphere;

          pointerDragBehavior = new BABYLON.PointerDragBehavior({});
          pointerDragBehavior.useObjectOrientationForDragging = false;
          pointerDragBehavior.onDragStartObservable.add((event) => {
            console.log("dragStart");
            console.log(event);
          });
          pointerDragBehavior.onDragObservable.add((event) => {
            console.log("drag");
            console.log(event);
            //scene.removeMesh(line1)
            spheresXs[i] = spheres[i].position.x;
            spheresYs[i] = spheres[i].position.y;
            spheresZs[i] = spheres[i].position.z;

            resetArrows();
          });
          pointerDragBehavior.onDragEndObservable.add((event) => {
            console.log("dragEnd");
            console.log(event);

            spheresXs[i] = spheres[i].position.x;
            spheresYs[i] = spheres[i].position.y;
            spheresZs[i] = spheres[i].position.z;

            resetArrows();
          });
          dragBehaviors[i] = pointerDragBehavior;
          spheres[i].addBehavior(dragBehaviors[i]);
        }

        for (let i = 0; i < quantity; i++) {
          for (let j = 0; j < quantity; j++) {
            if (matrixSm[i][j] != 0) {
              let name = `CenterSphere`;
              let sphere = BABYLON.MeshBuilder.CreateSphere(
                name,
                { diameter: 0.5, segments: 32 },
                scene
              );
              var materialBox = new BABYLON.StandardMaterial("texture1", scene);
              materialBox.diffuseColor = new BABYLON.Color3(0.38, 0.01, 0.97); //Green

              sphere.material = materialBox;
              let variance1 = (spheresXs[i] + spheresXs[j]) / 2;
              let variance2 = (spheresYs[i] + spheresYs[j]) / 2;
              let variance3 = (spheresZs[i] + spheresZs[j]) / 2;

              sphere.position = new BABYLON.Vector3(
                variance1,
                variance2,
                variance3
              );
              centerX[i][j] = variance1;
              centerY[i][j] = variance2;
              centerZ[i][j] = variance3;
              sphere.outlineWidth = 0.1;
              sphereNode.addChild(sphere);
              centerSpheres[i][j] = sphere;

              var advancedTexture3 =
                BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

              var rect1 = new BABYLON.GUI.Rectangle();
              rect1.width = "25px";
              rect1.height = rect1.width;

              rect1.color = dark;

              rect1.thickness = 2;
              rect1.background = skinColor;
              advancedTexture3.addControl(rect1);

              var label = new BABYLON.GUI.TextBlock();

              if (weights[i][j] != 0) {
                label.text = weights[i][j];
              } else if (weights[i][j] == 0) {
                label.text = weights[j][i];
              }

              console.log(weights[i][j]);
              label.color = dark;
              weightsRectsLabels[i][j] = label;

              rect1.addControl(weightsRectsLabels[i][j]);
              weightsRects[i][j] = rect1;

              weightsRects[i][j].linkWithMesh(centerSpheres[i][j]);
            }
          }
        }

        for (let i = 0; i < quantity; i++) {
          for (let j = 0; j < quantity; j++) {
            if (weights[i][j] != 0) {
              points1[i][j] = [spheres[j].position, spheres[i].position];

              line1[i][j] = BABYLON.CreateGreasedLine(
                "lines1",
                {
                  points: points1[i][j],
                  widths,
                  widtsDistribution:
                    BABYLON.GreasedLineMeshWidthDistribution
                      .WIDTH_DISTRIBUTION_START,
                },
                {
                  color: new BABYLON.Color4(r, g, b),
                },
                scene
              );

              // the arrow cap to the lineRed instance to join it with the lineRed
              cap1[i][j] = BABYLON.GreasedLineTools.GetArrowCap(
                new BABYLON.Vector3(
                  0.75 * (spheres[i].position.x - spheres[j].position.x) +
                    spheres[j].position.x,
                  0.75 * (spheres[i].position.y - spheres[j].position.y) +
                    spheres[j].position.y,
                  0.75 * (spheres[i].position.z - spheres[j].position.z) +
                    spheres[j].position.z
                ),
                new BABYLON.Vector3(
                  spheres[i].position.x - spheres[j].position.x,
                  spheres[i].position.y - spheres[j].position.y,
                  spheres[i].position.z - spheres[j].position.z
                ),
                0.24,
                150,
                150
              );
              BABYLON.CreateGreasedLine(
                "linesWays",
                {
                  points: cap1[i][j].points,
                  widths: cap1[i][j].widths,
                  widthDistribution:
                    BABYLON.GreasedLineMeshWidthDistribution
                      .WIDTH_DISTRIBUTION_START,
                  instance: line1[i][j],
                },
                scene
              );
            }
          }
        }

        for (let i = 0; i < quantity; i++) {
          spheres[i].actionManager = new BABYLON.ActionManager(scene);

          const hl = new BABYLON.HighlightLayer("hl1", scene);

          var advancedTexture2 =
            BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
          advancedTexture2.idealWidth = 900;

          var rectPopUp = new BABYLON.GUI.Rectangle();
          rectPopUp.width = "40px";
          rectPopUp.height = "40px";
          rectPopUp.cornerRadius = 20;
          rectPopUp.color = dark;
          rectPopUp.thickness = 4;
          //rectPopUp.background = "Black";
          rectsPopUp[i] = rectPopUp;

          var gradientDefault = new BABYLON.GUI.LinearGradient(0, 0, 400, 400);
          gradientDefault.addColorStop(0, skinColor);
          gradientDefault.addColorStop(1, skinColor);
          rectPopUp.backgroundGradient = gradientDefault;

          var label = new BABYLON.GUI.TextBlock();
          label.text = i + 1;
          label.color = dark;
          labelsPopUp[i] = label;

          var target = new BABYLON.GUI.Ellipse();
          target.width = "4px";
          target.height = "4px";
          target.color = "Black";
          target.thickness = 4;
          target.background = "White";

          advancedTexture.addControl(rectsPopUp[i]);
          rectsPopUp[i].linkWithMesh(spheres[i]);

          rectsPopUp[i].addControl(labelsPopUp[i]);

          advancedTexture.addControl(target);
          target.linkWithMesh(spheres[i]);

          spheres[i].actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
              BABYLON.ActionManager.OnPointerOverTrigger,
              function (ev) {
                scene.hoverCursor = "pointer";
                hl.addMesh(spheres[i], BABYLON.Color3.Green());
                advancedTexture.isVisible = true;
                rectsPopUp[i].isVisible = true;
                target.isVisible = true;
                linesPopUp[i].isVisible = true;
              }
            )
          );

          spheres[i].actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
              BABYLON.ActionManager.OnPointerOutTrigger,
              function (ev) {
                hl.removeMesh(spheres[i], BABYLON.Color3.White());
                if (isPopUpsShown == false) {
                  advancedTexture2.isVisible = false;
                  rectsPopUp[i].isVisible = false;
                  target.isVisible = false;
                  linesPopUp[i].isVisible = false;
                }
              }
            )
          );
        }
      };

      var resetArrows = function () {
        for (let t = 0; t < quantity; t++) {
          for (let j = 0; j < quantity; j++) {
            scene.removeMesh(line1[t][j]);
          }
        }

        for (let t = 0; t < quantity; t++) {
          for (let j = 0; j < quantity; j++) {
            if (matrixSm[t][j] != 0) {
              let variance1 = (spheresXs[t] + spheresXs[j]) / 2;
              let variance2 = (spheresYs[t] + spheresYs[j]) / 2;
              let variance3 = (spheresZs[t] + spheresZs[j]) / 2;

              centerSpheres[t][j].position = new BABYLON.Vector3(
                variance1,
                variance2,
                variance3
              );
              centerX[t][j] = variance1;
              centerY[t][j] = variance2;
              centerZ[t][j] = variance3;

              centerSpheres[j][t].position = new BABYLON.Vector3(
                variance1,
                variance2,
                variance3
              );
              centerX[j][t] = variance1;
              centerY[j][t] = variance2;
              centerZ[j][t] = variance3;

              points1[t][j] = [spheres[j].position, spheres[t].position];

              //width1[t][j] = 100
              line1[t][j] = BABYLON.CreateGreasedLine(
                "lines1",
                {
                  points: points1[t][j],
                  widths,
                  /*BABYLON.GreasedLineMeshWidthDistribution
                      .WIDTH_DISTRIBUTION_START = 10,*/
                },
                {
                  color: new BABYLON.Color4(r, g, b),
                },
                scene
              );

              // the arrow cap to the lineRed instance to join it with the lineRed
              cap1[t][j] = BABYLON.GreasedLineTools.GetArrowCap(
                new BABYLON.Vector3(
                  0.75 * (spheres[j].position.x - spheres[t].position.x) +
                    spheres[t].position.x,
                  0.75 * (spheres[j].position.y - spheres[t].position.y) +
                    spheres[t].position.y,
                  0.75 * (spheres[j].position.z - spheres[t].position.z) +
                    spheres[t].position.z
                ),
                new BABYLON.Vector3(
                  spheres[j].position.x - spheres[t].position.x,
                  spheres[j].position.y - spheres[t].position.y,
                  spheres[j].position.z - spheres[t].position.z
                ),
                0.24,
                150,
                150
              );
              BABYLON.CreateGreasedLine(
                "linesWays",
                {
                  points: cap1[t][j].points,
                  widths: cap1[t][j].widths,
                  widthDistribution:
                    BABYLON.GreasedLineMeshWidthDistribution
                      .WIDTH_DISTRIBUTION_START,
                  instance: line1[t][j],
                },
                scene
              );
            }
          }
        }
      };

      var isInfoOpen = false;
      var infoButton = function () {
        var advancedTexture =
          BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

        var buttonInfo = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonInfo",
          "i"
        );
        buttonInfo.width = "50px";
        buttonInfo.height = "50px";
        buttonInfo.fontSize = "5%";
        buttonInfo.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        buttonInfo.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        buttonInfo.textHorizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        buttonInfo.top = "20px";
        buttonInfo.left = "20px";
        buttonInfo.color = "#f7f0eb";
        buttonInfo.cornerRadius = 25;
        buttonInfo.fontStyle = "Bold";
        buttonInfo.background = dark;
        advancedTexture.addControl(buttonInfo);

        var rectInfo = new BABYLON.GUI.Rectangle();
        rectInfo.width = "600px";
        rectInfo.height = "95%";
        rectInfo.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        rectInfo.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        rectInfo.thickness = 0;
        rectInfo.background = dark;
        rectInfo.isVisible = isInfoOpen;

        advancedTexture.addControl(rectInfo);

        var controls = new BABYLON.GUI.Image(
          "img",
          "https://raw.githubusercontent.com/pave228/Babylon/main/controls.png"
        );
        controls.width = "560px";
        controls.height = "1475px";
        //controls.top = "-400px";
        //controls.left = "650px";
        controls.outlineWidth = "0px";

        var sv = new BABYLON.GUI.ScrollViewer();
        sv.thickness = 1;
        sv.color = dark;
        sv.width = "98%";
        sv.height = "98%";
        //sv.top = "10px";
        sv.background = dark;
        sv.clipChildren = false;
        rectInfo.addControl(sv);
        rectInfo.addControl(sv);

        var stackV = new BABYLON.GUI.StackPanel();
        stackV.isVertical = true;

        stackV.addControl(controls);
        sv.addControl(stackV);

        buttonInfo.onPointerClickObservable.add(function () {
          if (isInfoOpen == 0) {
            buttonInfo.isVisible = false;
            isInfoOpen = true;
            infoButton();
            rectInfo.isVisible = false;

            console.log(isInfoOpen);
          } else {
            buttonInfo.isVisible = false;
            isInfoOpen = false;
            infoButton();
            rectInfo.isVisible = false;

            console.log(isInfoOpen);
          }
        });
      };

      var createScene = function () {
        //Функция выполнения логики программы
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color3(0.97, 0.94, 0.92);
        preScene(scene);

        floidUorshellVisualisation();
        graphOrWe(scene);
        var advancedTexture =
          BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        var diagramm = new BABYLON.GUI.Image(
          "img",
          "https://raw.githubusercontent.com/pave228/Babylon/main/floiduorshelldiag.png"
        );

        diagramm.width = "600px";
        diagramm.height = "500px";
        diagramm.left = 10;
        diagramm.top = -70;
        //diagramm.top = "280px";
        //diagramm.left = "-700px";
        diagramm.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        diagramm.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        diagramm.outlineWidth = "0px";

        advancedTexture.addControl(diagramm);
        textWindowFullScreen(1);

        infoButton();

        
        return scene;


      };
      window.initFunction = async function () {
        var asyncEngineCreation = async function () {
          try {
            return createDefaultEngine();
          } catch (e) {
            console.log(
              "the available createEngine function failed. Creating the default engine instead"
            );
            return createDefaultEngine();
          }
        };

        window.engine = await asyncEngineCreation();
        if (!engine) throw "engine should not be null.";
        startRenderLoop(engine, canvas);
        window.scene = createScene();
      };
      initFunction().then(() => {
        sceneToRender = scene;
      });

      // Resize
      window.addEventListener("resize", function () {
        engine.resize();
      });
    </script>
  </body>
</html>
