<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>Алгоритм Дейкстры</title>

    <!-- Babylon.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
    <script src="https://cdn.babylonjs.com/recast.js"></script>
    <script src="https://cdn.babylonjs.com/ammo.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>
    <script src="https://cdn.babylonjs.com/Oimo.js"></script>
    <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

    <style>
      html,
      body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }

      #canvasZone {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
    <script>
      var canvas = document.getElementById("renderCanvas");

      var startRenderLoop = function (engine, canvas) {
        engine.runRenderLoop(function () {
          if (sceneToRender && sceneToRender.activeCamera) {
            sceneToRender.render();
          }
        });
      };

      var engine = null;
      var scene = null;
      var sceneToRender = null;
      var createDefaultEngine = function () {
        return new BABYLON.Engine(canvas, true, {
          preserveDrawingBuffer: true,
          stencil: true,
          disableWebGL2Support: false,
        });
      };
      var titels = [
        "Алгоритм Дейкстры",
        "Принцип работы",
        "Жадный алгоритм",
        "Визуализация",
        "Реализация",
        "Пример",
        "Пример",
        "Сложность алгоритма",
        "Применение",
        "Заключение",
      ];
      var texts = [
        "   Алгоритм Дейкстры изобретен нидерландским ученым Эдсгером Дейкстрой.\n   Алгоритм предназначен для нахождения кратчайших путей из исходной вершины графа до всех остальных. Он работает только для графов без ребер отрицательного веса, так как выбирает следующую вершину на основе кратчайшего прилегающего ребра, из-за чего при весе меньше 0 алгоритм может войти в бесконечный цикл.",
        "   Каждой вершине из множества вершин V сопоставим метку — минимальное известное расстояние от этой вершины до стартовой вершины a.\n   Алгоритм работает пошагово — на каждом шаге он «посещает» одну вершину и пытается уменьшать метки.\n   Работа алгоритма завершается, когда все вершины посещены.",
        "   Как упоминалось ранее, алгоритм является жадным, так как основан на принятии локально оптимальных решений на каждом этапе, допуская, что конечное решение также окажется оптимальным. На каждом шагу мы ищем вершину с наименьшим весом, в которой мы еще не бывали, после чего обновляем значения других вершин. При этом можно доказать, что кратчайшие пути, найденные в вершинах, являются оптимальными. Доказательство будет схожим с логикой поиска в ширину, только в нем мы опираемся на известные кратчайшие пути, а не на найденные по мере обхода графа ребра.",
        "   На визуализации представлен неориентированный взвешенный граф. Алгоритм запущен из первой вершины. Зеленым помечены вершины, расстояние до которых определено окончательно. Красным помечены вершины, до которых кратчайшее расстояние определено лишь предварительно. Фиолетовым подсвечивается вершина, до которой алгоритм пытается найти путь. Также фиолетовым будут помечаться ребра, ранее предварительно помеченные как участвующие в создании кратчайшего пути, но в дальнейшем из него вычеркнутые. Слева снизу представлено окно информации, в котором отслеживаются изменения массива кратчайших расстояний от исходной вершины, а также переменных, отвечающих за промежуточную и конечную вершины, количество иттераций внешнего цикла и предварительно найденное кратчайшее расстояние.",
        "   Функция реализации алгоритма Дейкстры на языке JavaScript представлена ниже.\n   Функция принимает в качестве аргумента номер исходной вершины. Далее создаются массивы расстояний и рассмотренных вершин (dist и visited соответственно). Массив dist заполняется числами, в рамках данной реализации условно стремящимися к бесконечности, а массив visited нулями, обозначая, что все вершины графа еще не рассмотрены. Расстояние до исходной вершины устанавливается на ноль.\n   Далее посредством цикла перебираются все номера вершин графа. Создается переменная nearest, обозначающая ближайшую вершину, изначально равная -1. Во внутреннем цикле снова перебираются номера вершин (счетчик – переменная v). Если вершина еще не рассмотрена, и если nearest все еще равен -1, либо расстояние до ближайшей больше, чем до v-той, то nearest становится равна v.\n   После определения ближайшей вершины она помечается как рассмотренная. Запускается еще один внутренний цикл, перебирающий все вершины (счетчик – переменная j). Если нашлась смежная с ближайшей вершина, и если расстояние от исходной до смежной с ней вершины больше, чем сумма расстояний от исходной до ближайшей и до смежной с ближайшей, то данное расстояние перезаписывается.",
        "   К примеру, в итерации алгоритма, представленной в данный момент на визуализации, рассматривается вершина 1. Алгоритм нашел смежную ей вершину 4, пометив ее красным цветом.",
        "   До вершины 5 алгоритм не смог найти прямого пути. Пройдясь по всем вершинам и отметив все смежные рассматриваемой в итерации, он выберет ту, до которой расстояние является на данный момент минимальным и сделает ее промежуточной для достижения всех остальных (на визуализации это будет вершина 8).",
        "   В алгоритме Дейкстры требуется V раз определять ближайшую вершину и не более 2Е раз (в сумме по вершинам) производить релаксации. Таким образом, общая сложность алгоритма составляет О(V²+E).",
        "   Рассмотрим некоторые области, где алгоритм Дейкстры играет значительную роль:\n   Транспортные сети: алгоритм Дейкстры дает планировщикам возможность эффективно проектировать транспортные системы и перемещаться по ним;\n   Интернет-маршрутизация: алгоритм используется для поиска кратчайшего пути между серверами, обеспечивая более быструю и надежную связь в компьютерных сетях и Интернете;\n   Робототехника: алгоритм Дейкстры используется роботами в приложениях для поиска пути, чтобы найти самый короткий и безопасный маршрут, оптимизируя их навигационное мастерство;\n   Распределение ресурсов: алгоритм можно применять в таких областях, как управление проектами и логистика, для эффективного распределения ресурсов путем определения кратчайших путей и оптимального маршрутизации.",
        "   В конце работы алгоритма, проходя по зеленым ребрам графа будет возможно восстановить кратчайшие пути от исходной вершины до всех остальных. Предлагаем вам самостоятельно просмотреть отсаток визуализации, после чего перейти к следующей теме.",
      ];
      var index = 0;
      var isVisibleAfter = true; 

      /*var matrixSm = [
        [0, 15, 0, 0, 30],
        [15, 0, 0, 85, 0],
        [0, 0, 0, 0, 68],
        [0, 85, 0, 0, 45],
        [30, 0, 68, 45, 0],
      ];*/

      var matrixSm = [
        [0, 30, 0, 4, 0, 0, 0, 1, 0],
        [30, 0, 0, 0, 0, 5, 0, 0, 0],
        [0, 0, 0, 3, 0, 1, 12, 1, 0],
        [4, 0, 3, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 1, 0],
        [0, 5, 1, 0, 0, 0, 10, 0, 0],
        [0, 0, 12, 0, 0, 10, 0, 1, 0],
        [1, 0, 1, 0, 1, 0, 1, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
      ];

      var quantity = matrixSm.length;
      var spheres = [];
      var spheresXs = [];
      var spheresYs = [];
      var spheresZs = [];

      var lines = [];
      var gradients = [];

      var distText = [];

      for (let i = 0; i < quantity; i++) {
        lines[i] = [];
        gradients[i] = -1;
      }
      for (let i = 0; i < quantity; i++) {
        for (let j = 0; j < quantity; j++) {
          lines[i][j] = 0;
        }
      }

      var targets = [];
      var dragBehaviors = [];
      var rectsPopUp = [];
      var linesPopUp = [];
      var labelsPopUp = [];
      let isPopUpsShown = true;

      var centerX = []; //местоположение сфер с весом ребра
      var centerY = []; //местоположение сфер с весом ребра
      var centerZ = []; //местоположение сфер с весом ребра
      var centerSpheres = []; //массив хранения сфер весов
      var weights = [];
      var weightsRects = []; //матрица хранения выводимых прямоугольников
      var weightsRectsLabels = [];

      for (let i = 0; i < quantity; i++) {
        weights[i] = [];
        weightsRects[i] = [];
        weightsRectsLabels[i] = [];
      }

      for (let i = 0; i < quantity; i++) {
        for (let j = 0; j < quantity; j++) {
          weights[i][j] = 0;
          weightsRects[i][j] = 0;
          weightsRectsLabels[i][j] = 0;
        }
      }

      for (let i = 0; i < quantity; i++) {
        for (let j = 0; j < quantity; j++) {
          weights[i][j] = matrixSm[j][i];
        }
      }

      var points1 = []; //массив хранения крайних координат стрелочки
      var line1 = []; //массив хранения линий стрелочек
      var cap1 = []; //массив хранения указателей стрелочек

      var skinColor = "#e5ded6"; //"#EAEAE3""#272727""black"
      var dark = "#222222"; //"#fde401""white""#6303F7"
      var orange = "#FE6C21"; //"#ff652f"
      var green = "#3DD085"; //"#07ef93"
      var purple = "#BF4DEB";

      let isOr = false;
      let isWe = true;

      var images = [
        "https://raw.githubusercontent.com/pave228/Babylon/main/deicstra.jpg",
        "https://raw.githubusercontent.com/pave228/Babylon/main/deicstradiag.png"
      ];

      var setImage = function (imageIndex, rect, width, height) {
        var image = new BABYLON.GUI.Image("img", images[imageIndex]);
        image.width = width;
        image.height = height;
        image.outlineWidth = "4px";

        rect.addControl(image);
      };

      var preScene = function (scene) {
        //Функция создания необходимых элементов сцены
        var camera = new BABYLON.ArcRotateCamera(
          "camera",
          Math.PI / 3,
          Math.PI / 3,
          10,
          BABYLON.Vector3.Zero(),
          scene
        );

        camera.setTarget(BABYLON.Vector3.Zero());

        camera.position = new BABYLON.Vector3(1000, 0, -1000);

        camera.attachControl(canvas, true);
        camera.panningSensibility = 15;

        const light = new BABYLON.HemisphericLight(
          "light",
          new BABYLON.Vector3(0, 1, 0),
          scene
        );
        light.intensity = 0.7;
      };

      var deicstra = function (start) {
        var dist = [];
        var visited = [];
        for (let i = 0; i < quantity; i++) {
          dist[i] = 1e9;
          visited[i] = 0;
        }
        dist[start] = 0;
        for (let i = 0; i < quantity; i++) {
          var nearest = -1;
          for (let v = 0; v < quantity; v++) {
            if (visited[v] == 0 && (nearest == -1 || dist[nearest] > dist[v])) {
              nearest = v;
            }
          }
          visited[nearest] = 1;
          for (let j = 0; j < quantity; j++) {
            if (matrixSm[nearest][j] != 0) {
              if (dist[j] > dist[nearest] + matrixSm[nearest][j]) {
                dist[j] = dist[nearest] + matrixSm[nearest][j];
              }
            }
          }
        }
        console.log(dist);
      };

      var deicstraVisualisation = function (start) {
        var advancedTexture =
          BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

        var diagramm = new BABYLON.GUI.Image(
          "img",
          "https://raw.githubusercontent.com/pave228/Babylon/main/deicstradiag.png"
        );
        diagramm.width = "530px";
        diagramm.height = "480px";
        diagramm.left = 10;
        diagramm.top = -70;
        //diagramm.top = "280px";
        //diagramm.left = "-700px";
        diagramm.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        diagramm.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        diagramm.outlineWidth = "0px";

        advancedTexture.addControl(diagramm);

        var buttonNextLink = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonNextLink",
          "Алгоритм Форда-Беллмана ⇨"
        );
        buttonNextLink.width = "200px";
        buttonNextLink.height = "50px";
        buttonNextLink.fontSize = "2.5%";
        buttonNextLink.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonNextLink.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        buttonNextLink.top = "50px";
        buttonNextLink.left = "-20px";
        buttonNextLink.color = dark;
        //buttonNextLink.cornerRadius = 20;
        buttonNextLink.background = skinColor;
        //buttonNextLink.isVisible = false;
        buttonNextLink.thickness = 1;

        buttonNextLink.onPointerClickObservable.add(function () {
          window.open("fordbellman.html");
          window.close("deicstra.html");
        });

        advancedTexture.addControl(buttonNextLink);

        var gradientRed = new BABYLON.GUI.LinearGradient(0, 0, 400, 400);
        gradientRed.addColorStop(0, orange);
        gradientRed.addColorStop(1, orange);

        var gradientGreen = new BABYLON.GUI.LinearGradient(0, 0, 400, 400);
        gradientGreen.addColorStop(0, green);
        gradientGreen.addColorStop(1, green);

        var gradientDefault = new BABYLON.GUI.LinearGradient(0, 0, 400, 400);
        gradientDefault.addColorStop(0, skinColor);
        gradientDefault.addColorStop(1, skinColor);

        var gradientPurple = new BABYLON.GUI.LinearGradient(0, 0, 400, 400);
        gradientPurple.addColorStop(0, purple);
        gradientPurple.addColorStop(1, purple);

        var rectInfo = new BABYLON.GUI.Rectangle();
        rectInfo.width = "420px";
        rectInfo.height = "200px";
        //rectInfo.cornerRadius = 10;
        rectInfo.color = dark;
        rectInfo.thickness = 1;
        rectInfo.background = skinColor;
        rectInfo.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        rectInfo.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;

        advancedTexture.addControl(rectInfo);

        var textblockInfo = new BABYLON.GUI.TextBlock();
        textblockInfo.color = dark;
        textblockInfo.textWrapping = true;

        textblockInfo.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        textblockInfo.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        textblockInfo.textHorizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        textblockInfo.textVerticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        textblockInfo.textWrapping = BABYLON.GUI.TextWrapping.WordWrap;
        textblockInfo.resizeToFit = true;
        textblockInfo.paddingLeft = "10px";
        textblockInfo.paddingRight = "20px";
        textblockInfo.paddingBottom = "15px";
        textblockInfo.fontSize = "20";

        rectInfo.addControl(textblockInfo);

        var buttonNextStepGreen = BABYLON.GUI.Button.CreateSimpleButton(
          "butNextStep",
          "⇨"
        );
        buttonNextStepGreen.width = "40px";
        buttonNextStepGreen.height = "40px";
        buttonNextStepGreen.fontSize = "6%";
        buttonNextStepGreen.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonNextStepGreen.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        buttonNextStepGreen.top = "-20px";
        buttonNextStepGreen.left = "-20px";
        buttonNextStepGreen.color = dark;
        //buttonNextStepGreen.cornerRadius = 20;
        buttonNextStepGreen.background = "#f7f0eb";
        buttonNextStepGreen.thickness = 0;

        advancedTexture.addControl(buttonNextStepGreen);

        var dist = [];
        var visited = [];

        for (let i = 0; i < quantity; i++) {
          dist[i] = 1e9;
          visited[i] = 0;
        }
        dist[start] = 0;

        var i = -1;
        var j = -1;
        buttonNextStepGreen.onPointerClickObservable.add(function () {
          for (let k = 0; k < quantity; k++) {
            distText[k] = dist[k];
            if (distText[k] == 1e9) {
              distText[k] = "∞";
            }
          }
          textblockInfo.text =
            "Путь проходит через вершину " +
            (nearest + 1) +
            "\nКонечная вершина " +
            (j + 1) +
            "\nМассив расстояний " +
            distText +
            "\nКоличество итераций внешнего цикла " +
            (i + 1) +
            "\nЛучшее расстояние " +
            distText[j];
          for (let k = 0; k < quantity; k++) {
            if (rectsPopUp[k].backgroundGradient == gradientPurple) {
              if (gradients[k] == -1) {
                rectsPopUp[k].backgroundGradient = gradientDefault;
              } else if (gradients[k] == 1) {
                rectsPopUp[k].backgroundGradient = gradientRed;
              } else if (gradients[k] == 2) {
                rectsPopUp[k].backgroundGradient = gradientGreen;
              }
            }
          }
          i++;
          if (i > quantity - 1) {
            buttonNextStepGreen.isVisible = false;
            /*if(buttonNextStepBlue.isVisible == true){
                buttonNextStepBlue.isVisible = false;
            }*/
          }
          var nearest = -1;
          for (let v = 0; v < quantity; v++) {
            if (visited[v] == 0 && (nearest == -1 || dist[nearest] > dist[v])) {
              nearest = v;
              for (let k = 0; k < quantity; k++) {
                distText[k] = dist[k];
                if (distText[k] == 1e9) {
                  distText[k] = "∞";
                }
              }
              textblockInfo.text =
                "Путь проходит через вершину " +
                (nearest + 1) +
                "\nКонечная вершина " +
                (j + 1) +
                "\nМассив расстояний " +
                distText +
                "\nКоличество итераций внешнего цикла " +
                (i + 1) +
                "\nЛучшее расстояние " +
                distText[j];
            }
          }
          visited[nearest] = 1;
          rectsPopUp[nearest].backgroundGradient = gradientGreen;
          for (let p = 0; p < quantity; p++) {
            if (
              rectsPopUp[p].backgroundGradient == gradientGreen &&
              lines[nearest][p].color == orange
            ) {
              lines[nearest][p].color = green;
              lines[p][nearest].color = green;
            }
          }

          gradients[nearest] = 2;

          var buttonNextStepBlue = BABYLON.GUI.Button.CreateSimpleButton(
            "butNextStep",
            "⇨"
          );
          buttonNextStepBlue.width = "40px";
          buttonNextStepBlue.height = "40px";
          buttonNextStepBlue.fontSize = "6%";
          buttonNextStepBlue.horizontalAlignment =
            BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
          buttonNextStepBlue.verticalAlignment =
            BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
          buttonNextStepBlue.top = "-20px";
          buttonNextStepBlue.left = "-20px";
          buttonNextStepBlue.color = dark;
          //buttonNextStepBlue.cornerRadius = 20;
          buttonNextStepBlue.background = "#f7f0eb";
          buttonNextStepBlue.thickness = 0;

          advancedTexture.addControl(buttonNextStepBlue);

          j = -1;
          buttonNextStepBlue.onPointerClickObservable.add(function () {
            for (let k = 0; k < quantity; k++) {
              if (rectsPopUp[k].backgroundGradient == gradientPurple) {
                if (gradients[k] == -1) {
                  rectsPopUp[k].backgroundGradient = gradientDefault;
                } else if (gradients[k] == 1) {
                  rectsPopUp[k].backgroundGradient = gradientRed;
                } else if (gradients[k] == 2) {
                  rectsPopUp[k].backgroundGradient = gradientGreen;
                }
              }
            }
            j++;
            rectsPopUp[j].backgroundGradient = gradientPurple;

            for (let k = 0; k < quantity; k++) {
              distText[k] = dist[k];
              if (distText[k] == 1e9) {
                distText[k] = "∞";
              }
            }
            textblockInfo.text =
              "Путь проходит через вершину " +
              (nearest + 1) +
              "\nКонечная вершина " +
              (j + 1) +
              "\nМассив расстояний " +
              distText +
              "\nКоличество итераций внешнего цикла " +
              (i + 1) +
              "\nЛучшее расстояние " +
              distText[j];
            if (j >= quantity - 1) {
              buttonNextStepBlue.isVisible = false;
            }

            if (matrixSm[nearest][j] != 0) {
              if (dist[j] > dist[nearest] + matrixSm[nearest][j]) {
                dist[j] = dist[nearest] + matrixSm[nearest][j];
                rectsPopUp[j].backgroundGradient = gradientRed;

                gradients[j] = 1;

                for (let k = 0; k < quantity; k++) {
                  distText[k] = dist[k];
                  if (distText[k] == 1e9) {
                    distText[k] = "∞";
                  }
                }
                textblockInfo.text =
                  "Путь проходит через вершину " +
                  (nearest + 1) +
                  "\nКонечная вершина " +
                  (j + 1) +
                  "\nМассив расстояний " +
                  distText +
                  "\nКоличество итераций внешнего цикла " +
                  (i + 1) +
                  "\nЛучшее расстояние " +
                  distText[j];
                for (let h = 0; h < quantity; h++) {
                  if (lines[j][h].color == orange) {
                    lines[j][h].color = purple;
                    lines[h][j].color = purple;
                  }
                }
                lines[j][nearest].color = orange;
                lines[j][nearest].lineWidth = 3;
                lines[nearest][j].color = orange;
                lines[nearest][j].lineWidth = 3;
              }
            }
          });
        });
        console.log(dist);
      };

      var textWindowFullScreen = function (howManySlides) {
        var advancedTexture =
          BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

        var rectInput = new BABYLON.GUI.Rectangle();
        rectInput.width = "100%";
        rectInput.height = "100%";
        //rectInput.cornerRadius = 10;
        //rectInput.color = skinColor;
        rectInput.thickness = 0;
        //rectInput.background = skinColor;

        var placeholder1 = new BABYLON.GUI.Image(
          "img",
          "https://raw.githubusercontent.com/pave228/Babylon/main/placeholder_left_bottom.jpg"
        );
        placeholder1.width = "1352px";
        placeholder1.height = "806px";
        placeholder1.top = "280px";
        placeholder1.left = "-700px";
        placeholder1.outlineWidth = "0px";

        var placeholder2 = new BABYLON.GUI.Image(
          "img",
          "https://raw.githubusercontent.com/pave228/Babylon/main/placeholder_left_top.jpg"
        );
        placeholder2.width = "1227px";
        placeholder2.height = "629px";
        placeholder2.top = "-500px";
        placeholder2.left = "-650px";
        placeholder2.outlineWidth = "0px";

        var placeholder3 = new BABYLON.GUI.Image(
          "img",
          "https://raw.githubusercontent.com/pave228/Babylon/main/placeholder_right_top.jpg"
        );
        placeholder3.width = "1338px";
        placeholder3.height = "960px";
        placeholder3.top = "-400px";
        placeholder3.left = "650px";
        placeholder3.outlineWidth = "0px";

        placeholder1.alpha = 0.1;
        placeholder2.alpha = 0.15;
        placeholder3.alpha = 0.1;
        rectInput.addControl(placeholder1);
        rectInput.addControl(placeholder2);
        rectInput.addControl(placeholder3);

        var gradientDefault = new BABYLON.GUI.LinearGradient(0, 0, 400, 400);
        gradientDefault.addColorStop(0, skinColor);
        gradientDefault.addColorStop(1, skinColor);
        rectInput.backgroundGradient = gradientDefault;

        var title = new BABYLON.GUI.TextBlock();
        title.width = "90%";
        title.fontSize = "5%";
        title.color = dark;
        title.top = "-45%";
        title.fontStyle = "Bold";
        title.textWrapping = true;
        title.text = titels[index];
        rectInput.addControl(title);

        var textblock = new BABYLON.GUI.TextBlock();
        //textblock.width = "99%"
        //textblock.fontSize = "5%";
        textblock.color = dark;
        //textblock.top = "-45%";
        textblock.textWrapping = true;
        textblock.text = texts[index];
        textblock.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        textblock.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        textblock.textHorizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        textblock.textVerticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        textblock.textWrapping = BABYLON.GUI.TextWrapping.WordWrap;
        textblock.resizeToFit = true;
        textblock.paddingTop = "10px";
        textblock.paddingLeft = "30px";
        textblock.paddingRight = "20px";
        textblock.paddingBottom = "15px";
        textblock.fontSize = "25";

        var buttonNext = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonNext",
          "⇨"
        );
        buttonNext.width = "40px";
        buttonNext.height = "40px";
        buttonNext.fontSize = "6%";
        buttonNext.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonNext.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        buttonNext.top = "-20px";
        buttonNext.left = "-20px";
        buttonNext.color = dark;
        //buttonNext.cornerRadius = 20;
        buttonNext.background = skinColor;
        buttonNext.thickness = 0;

        if (index == howManySlides - 1) {
          buttonNext.onPointerClickObservable.add(function () {
            rectInput.isVisible = false;
            index++;
            console.log(index);
            textWindowFramed();
          });
        } else {
          buttonNext.onPointerClickObservable.add(function () {
            rectInput.isVisible = false;
            index++;
            console.log(index);
          });
        }

        var buttonBack = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonBack",
          "⇦"
        );
        buttonBack.width = "40px";
        buttonBack.height = "40px";
        buttonBack.fontSize = "6%";
        buttonBack.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        buttonBack.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        buttonBack.top = "-20px";
        buttonBack.left = "20px";
        buttonBack.color = dark;
        //buttonBack.cornerRadius = 30;
        buttonBack.background = skinColor;
        buttonBack.thickness = 0;

        if (index > 0) {
          buttonBack.onPointerClickObservable.add(function () {
            rectInput.isVisible = false;
            index--;
            console.log(index);
            textWindowFullScreen();
          });
        } else {
          buttonBack.isVisible = false;
        }

        var buttonHome = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonHome",
          "⌂"
        );
        buttonHome.width = "40px";
        buttonHome.height = "40px";
        buttonHome.fontSize = "6%";
        buttonHome.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        buttonHome.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        buttonHome.top = "-20px";
        buttonHome.left = "20px";
        buttonHome.color = dark;
        //buttonHome.cornerRadius = 30;
        buttonHome.background = skinColor;
        buttonHome.thickness = 0;

        buttonHome.onPointerClickObservable.add(function () {
          window.open("homePage.html");
          window.close("deicstra.html");
        });

        var sv = new BABYLON.GUI.ScrollViewer();
        sv.thickness = 1;
        sv.color = dark;
        sv.width = "90%";
        sv.height = "75%";
        sv.top = "10px";
        sv.background = skinColor;
        sv.clipChildren = false;
        rectInput.addControl(sv);
        rectInput.addControl(sv);

        var stackV = new BABYLON.GUI.StackPanel();
        stackV.isVertical = true;

        stackV.addControl(textblock);
        sv.addControl(stackV);

        advancedTexture.addControl(rectInput);

        setImage(1, stackV, "808px", "740px")

        rectInput.addControl(buttonNext);
        rectInput.addControl(buttonBack);
        rectInput.addControl(buttonHome);
      };

      var textWindowFramed = function () {
        var advancedTexture =
          BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

        var rectInput = new BABYLON.GUI.Rectangle();
        rectInput.width = "40%";
        rectInput.height = "100%";
        //rectInput.cornerRadius = 10;
        rectInput.color = dark;
        rectInput.thickness = 1;
        rectInput.background = skinColor;
        rectInput.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        rectInput;

        hideShowRectButtons(rectInput, advancedTexture, "right", "top");

        advancedTexture.addControl(rectInput);

        var gradientDefault = new BABYLON.GUI.LinearGradient(0, 0, 400, 400);
        gradientDefault.addColorStop(0, skinColor);
        gradientDefault.addColorStop(1, skinColor);
        rectInput.backgroundGradient = gradientDefault;

        var title = new BABYLON.GUI.TextBlock();
        title.width = "75%";
        title.fontSize = "5%";
        title.color = dark;
        title.top = "-45%";
        title.textWrapping = true;
        title.text = titels[index];
        rectInput.addControl(title);

        var textblock = new BABYLON.GUI.TextBlock();
        //textblock.width = "99%"
        //textblock.fontSize = "5%";
        textblock.color = dark;
        //textblock.top = "-45%";
        textblock.textWrapping = true;
        textblock.text = texts[index];
        textblock.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        textblock.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        textblock.textHorizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        textblock.textVerticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        textblock.textWrapping = BABYLON.GUI.TextWrapping.WordWrap;
        textblock.resizeToFit = true;
        textblock.paddingTop = "10px";
        textblock.paddingLeft = "30px";
        textblock.paddingRight = "20px";
        textblock.paddingBottom = "15px";
        textblock.fontSize = "25";

        var buttonNext = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonNext",
          "⇨"
        );
        buttonNext.width = "40px";
        buttonNext.height = "40px";
        buttonNext.fontSize = "6%";
        buttonNext.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonNext.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        buttonNext.top = "-20px";
        buttonNext.left = "-20px";
        buttonNext.color = dark;
        //buttonNext.cornerRadius = 20;
        buttonNext.background = skinColor;
        buttonNext.thickness = 0;

        var buttonNextLink = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonNextLink",
          "⇨"
        );
        buttonNextLink.width = "40px";
        buttonNextLink.height = "40px";
        buttonNextLink.fontSize = "6%";
        buttonNextLink.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonNextLink.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        buttonNextLink.top = "-20px";
        buttonNextLink.left = "-20px";
        buttonNextLink.color = dark;
        //buttonNextLink.cornerRadius = 20;
        buttonNextLink.background = skinColor;
        buttonNextLink.isVisible = false;
        buttonNextLink.thickness = 0;

        var buttonBack = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonBack",
          "⇦"
        );
        buttonBack.width = "40px";
        buttonBack.height = "40px";
        buttonBack.fontSize = "6%";
        buttonBack.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        buttonBack.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        buttonBack.top = "-20px";
        buttonBack.left = "20px";
        buttonBack.color = dark;
        //buttonBack.cornerRadius = 30;
        buttonBack.background = skinColor;
        buttonBack.thickness = 0;

        var buttonHome = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonHome",
          "⌂"
        );
        buttonHome.width = "40px";
        buttonHome.height = "40px";
        buttonHome.fontSize = "6%";
        buttonHome.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        buttonHome.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        buttonHome.top = "-20px";
        //buttonHome.left = "20px";
        buttonHome.color = dark;
        //buttonHome.cornerRadius = 30;
        buttonHome.background = skinColor;
        buttonHome.thickness = 0;

        buttonHome.onPointerClickObservable.add(function () {
          window.open("homePage.html");
          window.close("deicstra.html");
        });

        var sv = new BABYLON.GUI.ScrollViewer();
        sv.thickness = 1;
        sv.color = dark;
        sv.width = "90%";
        sv.height = "75%";
        sv.top = "10px";
        sv.background = skinColor;
        sv.clipChildren = false;
        rectInput.addControl(sv);
        rectInput.addControl(sv);

        var stackV = new BABYLON.GUI.StackPanel();
        stackV.isVertical = true;

        stackV.addControl(textblock);
        sv.addControl(stackV);

        rectInput.addControl(buttonNext);
        //rectInput.addControl(buttonBack);
        rectInput.addControl(buttonHome);

        buttonNext.onPointerClickObservable.add(function () {
          rectInput.isVisible = false;
          index++;
          console.log(index);
          textWindowFramed();
        });
        buttonBack.onPointerClickObservable.add(function () {
          rectInput.isVisible = false;
          index--;
          console.log(index);
          textWindowFramed();
        });

        if (index == 4) {
          setImage(0, stackV, "342px", "486px");
        }

        if (index == texts.length - 1) {
          buttonNextLink.onPointerClickObservable.add(function () {
            rectInput.isVisible = false;
            buttonNext.isVisible = false;
          });
          buttonNextLink.isVisible = true;
          rectInput.addControl(buttonNextLink);
        }
      };

      var hideShowRectButtons = function (
        rect,
        advancedTexture,
        corner_RL,
        corner_TB
      ) {
        var buttonFullScreen = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonFullScreen",
          "❐"
        );
        buttonFullScreen.width = "30px";
        buttonFullScreen.height = "30px";
        buttonFullScreen.fontSize = "20";
        buttonFullScreen.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonFullScreen.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        buttonFullScreen.top = "5px";
        buttonFullScreen.left = "-5px";
        buttonFullScreen.color = dark;
        buttonFullScreen.thickness = 2;
        //buttonFullScreen.cornerRadius = 20;
        buttonFullScreen.background = skinColor;

        var buttonWindowed = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonWindowed",
          "❐"
        );
        buttonWindowed.width = "30px";
        buttonWindowed.height = "30px";
        buttonWindowed.fontSize = "20";
        buttonWindowed.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonWindowed.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        buttonWindowed.top = "5px";
        buttonWindowed.left = "-5px";
        buttonWindowed.color = dark;
        buttonWindowed.thickness = 2;
        //buttonWindowed.cornerRadius = 20;
        buttonWindowed.isVisible = false;
        buttonWindowed.background = skinColor;

        var buttonHideWindow = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonHideWindow",
          "—"
        );
        buttonHideWindow.width = "30px";
        buttonHideWindow.height = "30px";
        buttonHideWindow.fontSize = "20";
        buttonHideWindow.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonHideWindow.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        buttonHideWindow.top = "5px";
        buttonHideWindow.left = "-40px";
        buttonHideWindow.color = dark;
        buttonHideWindow.thickness = 2;
        //buttonHideWindow.cornerRadius = 20;
        //buttonHideWindow.isVisible = false;
        buttonHideWindow.background = skinColor;

        var buttonShowWindow = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonShowWindow",
          "❐"
        );
        buttonShowWindow.width = "30px";
        buttonShowWindow.height = "30px";
        buttonShowWindow.fontSize = "20";
        buttonShowWindow.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        buttonShowWindow.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        buttonShowWindow.top = "5px";
        buttonShowWindow.left = "-5px";
        buttonShowWindow.color = dark;
        buttonShowWindow.thickness = 2;
        //buttonShowWindow.cornerRadius = 20;
        //buttonShowWindow.isVisible = false;
        buttonShowWindow.background = skinColor;

        var rectWidth = rect.width;
        var rectHeight = rect.height;

        var rectHiden = new BABYLON.GUI.Rectangle();
        rectHiden.isVisible = false;
        rectHiden.width = "42px";
        rectHiden.height = "42px";
        rectHiden.color = dark;
        rectHiden.thickness = 0;
        rectHiden.background = "#f7f0eb";
        rectHiden.alpha = 0.15;
        if (corner_TB == "top") {
          rectHiden.verticalAlignment =
            BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        } else if (corner_TB == "bottom") {
          rectHiden.verticalAlignment =
            BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        }

        if (corner_RL == "right") {
          rectHiden.horizontalAlignment =
            BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        } else if (corner_RL == "left") {
          rectHiden.horizontalAlignment =
            BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        }

        buttonWindowed.onPointerClickObservable.add(function () {
          rect.width = rectWidth;
          rect.height = rectHeight;
          buttonWindowed.isVisible = false;
          buttonFullScreen.isVisible = true;
        });

        buttonFullScreen.onPointerClickObservable.add(function () {
          rect.width = "100%";
          rect.height = "100%";
          buttonFullScreen.isVisible = false;
          buttonWindowed.isVisible = true;
        });

        buttonHideWindow.onPointerClickObservable.add(function () {
          rect.isVisible = false;
          rectHiden.isVisible = true;

          //buttonFullScreen.isVisible = false;
          //buttonWindowed.isVisible = true;
        });

        buttonShowWindow.onPointerClickObservable.add(function () {
          rect.isVisible = true;
          rectHiden.isVisible = false;

          //buttonFullScreen.isVisible = false;
          //buttonWindowed.isVisible = true;
        });

        rectHiden.addControl(buttonShowWindow);
        advancedTexture.addControl(rectHiden);
        rect.addControl(buttonFullScreen);
        rect.addControl(buttonWindowed);
        rect.addControl(buttonHideWindow);
      };

      var xs = [];
      var ys = [];
      var getCoord = function () {
        var q = quantity;
        //var q = 10;
        var r = q;
        var j = 0;
        for (i = 0; i < Math.PI * 2; i += (Math.PI * 2) / q) {
          x = r * Math.sin(i);
          y = r * Math.cos(i);
          xs[j] = x * 20;
          ys[j] = y * 20;
          j++;
        }
      };

      var graphNotOrWe = function (advancedTexture, scene) {
        getCoord();
        var advancedTexture =
          BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

        let sphereNum = 0;
        let sphereNode = new BABYLON.Mesh("spheres", scene);

        for (let i = 0; i < quantity; i++) {
          spheres[i] = 0;
          spheresXs[i] = 0;
          spheresYs[i] = 0;
          spheresZs[i] = 0;
          targets[i] = 0;
          dragBehaviors[i] = 0;
          rectsPopUp[i] = 0;
          linesPopUp[i] = 0;
          labelsPopUp[i] = 0;

          centerSpheres[i] = [];
          centerX[i] = [];
          centerY[i] = [];
          centerZ[i] = [];

          line1[i] = [];
          points1[i] = [];
          cap1[i] = [];

          lines[i] = [];
        }
        for (let i = 0; i < quantity; i++) {
          for (let j = 0; j < quantity; j++) {
            centerSpheres[i][j] = 0;
            centerX[i][j] = 0;
            centerY[i][j] = 0;
            centerZ[i][j] = 0;

            line1[i][j] = 0;
            points1[i][j] = 0;
            cap1[i][j] = 0;

            lines[i][j] = 0;
          }
        }

        for (let i = 0; i < quantity; i++) {
          let name = `sphera${sphereNum++}`;
          let sphere = BABYLON.MeshBuilder.CreateSphere(
            name,
            { diameter: 32, segments: 32 },
            scene
          );
          let variance1 = xs[i];
          let variance2 = ys[i];
          let variance3 = 0; //Math.floor(Math.random()*50)

          sphere.position = new BABYLON.Vector3(
            variance1,
            variance2,
            variance3
          );

          spheresXs[i] = variance1;
          spheresYs[i] = variance2;
          spheresZs[i] = variance3;
          sphere.outlineWidth = 0.1;
          sphereNode.addChild(sphere);

          var target = new BABYLON.GUI.Ellipse();
          target.width = "20px";
          target.height = "20px";
          target.color = skinColor;

          target.thickness = 4;
          target.background = skinColor;
          advancedTexture.addControl(target);
          target.linkWithMesh(sphere);
          target.top = "10px";
          targets[i] = target;

          spheres[i] = sphere;

          pointerDragBehavior = new BABYLON.PointerDragBehavior({});
          pointerDragBehavior.useObjectOrientationForDragging = false;
          pointerDragBehavior.onDragStartObservable.add((event) => {});
          pointerDragBehavior.onDragObservable.add((event) => {
            //scene.removeMesh(line1)
            spheresXs[i] = spheres[i].position.x;
            spheresYs[i] = spheres[i].position.y;
            spheresZs[i] = spheres[i].position.z;

            resetArrowsAndWeights();
          });
          pointerDragBehavior.onDragEndObservable.add((event) => {
            spheresXs[i] = spheres[i].position.x;
            spheresYs[i] = spheres[i].position.y;
            spheresZs[i] = spheres[i].position.z;

            resetArrowsAndWeights();
          });
          dragBehaviors[i] = pointerDragBehavior;
          spheres[i].addBehavior(dragBehaviors[i]);
        }

        for (let i = 0; i < quantity; i++) {
          for (let j = 0; j < quantity; j++) {
            if (matrixSm[i][j] != 0) {
              var line = new BABYLON.GUI.Line();
              line.lineWidth = 1;
              line.color = dark;
              lines[i][j] = line;
              advancedTexture.addControl(lines[i][j]);
              lines[i][j].linkWithMesh(spheres[i]);
              lines[i][j].connectedControl = targets[j];
            }
          }
        }

        for (let i = 0; i < quantity; i++) {
          for (let j = 0; j < quantity; j++) {
            if (matrixSm[i][j] != 0) {
              let name = `CenterSphere`;
              let sphere = BABYLON.MeshBuilder.CreateSphere(
                name,
                { diameter: 0.5, segments: 32 },
                scene
              );
              var materialBox = new BABYLON.StandardMaterial("texture1", scene);
              materialBox.diffuseColor = new BABYLON.Color3(0.38, 0.01, 0.97); //Green

              sphere.material = materialBox;
              let variance1 = (spheresXs[i] + spheresXs[j]) / 2;
              let variance2 = (spheresYs[i] + spheresYs[j]) / 2;
              let variance3 = (spheresZs[i] + spheresZs[j]) / 2;

              sphere.position = new BABYLON.Vector3(
                variance1,
                variance2,
                variance3
              );
              centerX[i][j] = variance1;
              centerY[i][j] = variance2;
              centerZ[i][j] = variance3;
              sphere.outlineWidth = 0.1;
              sphereNode.addChild(sphere);
              centerSpheres[i][j] = sphere;

              var advancedTexture3 =
                BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

              var rect1 = new BABYLON.GUI.Rectangle();
              rect1.width = "25px";
              rect1.height = rect1.width;

              rect1.color = dark;

              rect1.thickness = 2;
              rect1.background = skinColor;
              advancedTexture3.addControl(rect1);

              var label = new BABYLON.GUI.TextBlock();

              if (weights[i][j] != 0) {
                label.text = weights[i][j];
              } else if (weights[i][j] == 0) {
                label.text = weights[j][i];
              }

              label.color = dark;
              if (label.text >= 99 || label.text <= -10) {
                rect1.widthInPixels += 10;
              }

              weightsRectsLabels[i][j] = label;

              rect1.addControl(weightsRectsLabels[i][j]);
              weightsRects[i][j] = rect1;

              weightsRects[i][j].linkWithMesh(centerSpheres[i][j]);
            }
          }
        }

        for (let i = 0; i < quantity; i++) {
          spheres[i].actionManager = new BABYLON.ActionManager(scene);

          const hl = new BABYLON.HighlightLayer("hl1", scene);

          var advancedTexture2 =
            BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
          advancedTexture2.idealWidth = 900;

          var rectPopUp = new BABYLON.GUI.Rectangle();
          rectPopUp.width = "40px";
          rectPopUp.height = "40px";
          rectPopUp.cornerRadius = 20;
          rectPopUp.color = dark;
          rectPopUp.thickness = 4;
          //rectPopUp.background = skinColor;
          rectsPopUp[i] = rectPopUp;

          var gradientDefault = new BABYLON.GUI.LinearGradient(0, 0, 400, 400);
          gradientDefault.addColorStop(0, skinColor);
          gradientDefault.addColorStop(1, skinColor);
          rectPopUp.backgroundGradient = gradientDefault;

          var label = new BABYLON.GUI.TextBlock();
          label.text = i + 1;
          label.color = dark;
          labelsPopUp[i] = label;

          var target = new BABYLON.GUI.Ellipse();
          target.width = "4px";
          target.height = "4px";
          target.color = skinColor;
          target.thickness = 4;
          target.background = dark;

          advancedTexture.addControl(rectsPopUp[i]);
          rectsPopUp[i].linkWithMesh(spheres[i]);

          rectsPopUp[i].addControl(labelsPopUp[i]);

          advancedTexture.addControl(target);
          target.linkWithMesh(spheres[i]);

          spheres[i].actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
              BABYLON.ActionManager.OnPointerOverTrigger,
              function (ev) {
                //scene.hoverCursor = "pointer";
                hl.addMesh(spheres[i], BABYLON.Color3.Green());
                advancedTexture.isVisible = true;
                rectsPopUp[i].isVisible = true;
                target.isVisible = true;
                linesPopUp[i].isVisible = true;
              }
            )
          );

          spheres[i].actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
              BABYLON.ActionManager.OnPointerOutTrigger,
              function (ev) {
                hl.removeMesh(spheres[i], BABYLON.Color3.White());
                if (isPopUpsShown == false) {
                  advancedTexture2.isVisible = false;
                  rectsPopUp[i].isVisible = false;
                  target.isVisible = false;
                  linesPopUp[i].isVisible = false;
                }
              }
            )
          );
        }
      };

      var resetArrowsAndWeights = function () {
        for (let t = 0; t < quantity; t++) {
          for (let j = 0; j < quantity; j++) {
            scene.removeMesh(line1[t][j]);
          }
        }

        for (let t = 0; t < quantity; t++) {
          for (let j = 0; j < quantity; j++) {
            if (matrixSm[t][j] != 0) {
              if (isWe == 1) {
                let variance1 = (spheresXs[t] + spheresXs[j]) / 2;
                let variance2 = (spheresYs[t] + spheresYs[j]) / 2;
                let variance3 = (spheresZs[t] + spheresZs[j]) / 2;

                centerSpheres[t][j].position = new BABYLON.Vector3(
                  variance1,
                  variance2,
                  variance3
                );
                centerX[t][j] = variance1;
                centerY[t][j] = variance2;
                centerZ[t][j] = variance3;

                centerSpheres[j][t].position = new BABYLON.Vector3(
                  variance1,
                  variance2,
                  variance3
                );
                centerX[j][t] = variance1;
                centerY[j][t] = variance2;
                centerZ[j][t] = variance3;
              }

              if (isOr == 1) {
                points1[t][j] = [spheres[j].position, spheres[t].position];
                line1[t][j] = BABYLON.CreateGreasedLine(
                  "lines1",
                  {
                    points: points1[t][j],
                    widtsDistribution:
                      BABYLON.GreasedLineMeshWidthDistribution
                        .WIDTH_DISTRIBUTION_START,
                  },
                  {
                    color: new BABYLON.Color4(r, g, b),
                  },
                  scene
                );
                cap1[t][j] = BABYLON.GreasedLineTools.GetArrowCap(
                  new BABYLON.Vector3(
                    0.75 * (spheres[j].position.x - spheres[t].position.x) +
                      spheres[t].position.x,
                    0.75 * (spheres[j].position.y - spheres[t].position.y) +
                      spheres[t].position.y,
                    0.75 * (spheres[j].position.z - spheres[t].position.z) +
                      spheres[t].position.z
                  ),
                  new BABYLON.Vector3(
                    spheres[j].position.x - spheres[t].position.x,
                    spheres[j].position.y - spheres[t].position.y,
                    spheres[j].position.z - spheres[t].position.z
                  ),
                  0.24,
                  15,
                  15
                );
                BABYLON.CreateGreasedLine(
                  "linesWays",
                  {
                    points: cap1[t][j].points,
                    widths: cap1[t][j].widths,
                    widthDistribution:
                      BABYLON.GreasedLineMeshWidthDistribution
                        .WIDTH_DISTRIBUTION_START,
                    instance: line1[t][j],
                  },
                  scene
                );
              }
            }
          }
        }
      };

      var isInfoOpen = false;
      var infoButton = function () {
        var advancedTexture =
          BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

        var buttonInfo = BABYLON.GUI.Button.CreateSimpleButton(
          "buttonInfo",
          "i"
        );
        buttonInfo.width = "50px";
        buttonInfo.height = "50px";
        buttonInfo.fontSize = "5%";
        buttonInfo.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        buttonInfo.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        buttonInfo.textHorizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        buttonInfo.top = "20px";
        buttonInfo.left = "20px";
        buttonInfo.color = "#f7f0eb";
        buttonInfo.cornerRadius = 25;
        buttonInfo.fontStyle = "Bold";
        buttonInfo.background = dark;
        advancedTexture.addControl(buttonInfo);

        var rectInfo = new BABYLON.GUI.Rectangle();
        rectInfo.width = "600px";
        rectInfo.height = "95%";
        rectInfo.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        rectInfo.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        rectInfo.thickness = 0;
        rectInfo.background = dark;
        rectInfo.isVisible = isInfoOpen;

        advancedTexture.addControl(rectInfo);

        var controls = new BABYLON.GUI.Image(
          "img",
          "https://raw.githubusercontent.com/pave228/Babylon/main/controls.png"
        );
        controls.width = "560px";
        controls.height = "1475px";
        //controls.top = "-400px";
        //controls.left = "650px";
        controls.outlineWidth = "0px";

        var sv = new BABYLON.GUI.ScrollViewer();
        sv.thickness = 1;
        sv.color = dark;
        sv.width = "98%";
        sv.height = "98%";
        //sv.top = "10px";
        sv.background = dark;
        sv.clipChildren = false;
        rectInfo.addControl(sv);
        rectInfo.addControl(sv);

        var stackV = new BABYLON.GUI.StackPanel();
        stackV.isVertical = true;

        stackV.addControl(controls);
        sv.addControl(stackV);

        buttonInfo.onPointerClickObservable.add(function () {
          if (isInfoOpen == 0) {
            buttonInfo.isVisible = false;
            isInfoOpen = true;
            infoButton();
            rectInfo.isVisible = false;

            console.log(isInfoOpen);
          } else {
            buttonInfo.isVisible = false;
            isInfoOpen = false;
            infoButton();
            rectInfo.isVisible = false;

            console.log(isInfoOpen);
          }
        });
      };

      var createScene = function () {
        //Функция выполнения логики программы
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color3(0.97, 0.94, 0.92);
        preScene(scene);
        graphNotOrWe(scene);
        deicstraVisualisation(0);
        textWindowFullScreen(1);

        infoButton();
        return scene;
      };
      window.initFunction = async function () {
        var asyncEngineCreation = async function () {
          try {
            return createDefaultEngine();
          } catch (e) {
            console.log(
              "the available createEngine function failed. Creating the default engine instead"
            );
            return createDefaultEngine();
          }
        };

        window.engine = await asyncEngineCreation();
        if (!engine) throw "engine should not be null.";
        startRenderLoop(engine, canvas);
        window.scene = createScene();
      };
      initFunction().then(() => {
        sceneToRender = scene;
      });

      // Resize
      window.addEventListener("resize", function () {
        engine.resize();
      });
    </script>
  </body>
</html>
